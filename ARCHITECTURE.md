# Weaver 아키텍처 문서

## 1. 핵심 철학: 하이브리드 접근법

Weaver는 두 가지 세계의 장점을 모두 제공하기 위해 하이브리드 아키텍처로 구축된 강력하고 현대적이며 안전한 Swift용 의존성 주입(DI) 프레임워크입니다. 두 가지 독특한 DI 패턴을 완벽하게 통합합니다:

1.  **모던 동기식 DI (`@Dependency`)**: `swift-dependencies`에서 영감을 받은 경량의 `TaskLocal` 기반 시스템입니다. 속도, 단순성, SwiftUI와의 완벽한 통합을 위해 설계되었으며, 의존성에 대한 동기적이고 컨텍스트를 인지하는 접근을 제공합니다.
2.  **전통적 비동기식 DI (`@Inject`)**: 복잡한 객체 그래프, 비동기 초기화, 세분화된 생명주기를 관리하기 위한 강력하고 기능이 풍부한 시스템입니다. 강력한 `WeaverKernel`과 `WeaverContainer`를 중심으로 구축되었습니다.

이 이중 접근법을 통해 개발자는 UI 컴포넌트와 간단한 서비스에는 간단한 `@Dependency`를 사용하고, 애플리케이션의 핵심 인프라에는 강력한 `@Inject` 시스템을 활용하는 등 상황에 맞는 최적의 도구를 선택할 수 있습니다.

## 2. 핵심 아키텍처 구성 요소

아키텍처는 모듈식이고 안전하며 성능이 뛰어나도록 설계되었습니다.

### 2.1. 두 가지 DI 시스템

#### `@Dependency` 시스템 ("간단한 경로")
- **`@Dependency` (프로퍼티 래퍼)**: 의존성 값에 즉각적이고 동기적인 접근을 제공합니다. 현재 컨텍스트(실행, 미리보기 또는 테스트)를 자동으로 감지하고 적절한 구현을 제공합니다.
- **`DependencyValues` (값 저장소)**: 현재 실행 컨텍스트에 대한 의존성 값을 보유하는 `TaskLocal` 구조체입니다. 이것이 바로 `@Dependency`가 추가 설정 없이 미리보기나 테스트를 위해 자동으로 구현을 전환할 수 있게 하는 핵심 기술입니다.
- **`DependencyKey` (정의)**: 두 시스템의 초석입니다. 의존성의 타입을 정의하고 `liveValue`, `previewValue`, `testValue`를 제공하는 프로토콜입니다. 이를 통해 모든 의존성이 설계 단계부터 테스트 및 미리보기가 가능하도록 보장합니다.

#### `@Inject` 시스템 ("강력한 경로")
- **`@Inject` (프로퍼티 래퍼)**: 의존성에 대한 비동기 접근을 제공합니다. 현재 스코프 내의 `WeaverContainer`에서 의존성을 해결합니다.
- **`WeaverContainer` (DI 컨테이너)**: 의존성의 생명주기를 관리하는 정교한 `actor`입니다. SOLID 원칙에 따라 책임을 다음과 같이 위임합니다:
    - **`ResolutionCoordinator`**: 의존성을 해결하고, 캐싱(`.shared`, `.weak`)하며, 인스턴스를 생성(`.transient`)하는 로직을 처리합니다.
    - **`ContainerLifecycleManager`**: 앱 생명주기 이벤트(`appDidEnterBackground` 등)를 관리하여 서비스가 올바른 의존성 순서로 초기화되고 종료되도록 보장합니다.
- **`WeaverKernel` (스코프 관리자)**: 각각 특정 `Scope`에 해당하는 여러 `WeaverContainer` 인스턴스를 관리하는 상위 레벨 `actor`입니다. 이를 통해 강력한 **스코프 기반 로딩** 기능을 사용할 수 있습니다.

### 2.2. 핵심 개념

#### 빌드 타임 안정성
이것은 Weaver의 가장 중요한 기능 중 하나입니다. 컨테이너가 생성되기 전에 `WeaverBuilder`는 전체 의존성 그래프에 대한 유효성 검사를 실행합니다.
- **`DependencyGraph`**: 모든 등록된 의존성을 분석하여 다음을 감지하는 구조체입니다:
    1.  **순환 참조**: 런타임에서의 무한 루프(예: A -> B -> C -> A)를 방지합니다.
    2.  **누락된 의존성**: 서비스에 필요한 모든 의존성이 등록되었는지 확인합니다.
이를 통해 일반적인 DI 오류를 런타임이 아닌 컴파일 타임에 발견할 수 있습니다.

#### 스코프 기반 점진적 로딩
앱 시작 성능을 최적화하기 위해 `WeaverKernel`은 스코프를 도입했습니다. 의존성은 할당된 스코프에 따라 점진적으로 로드됩니다:
- **`.startup`**: 앱 시작 시 즉시 로드됩니다. 로깅이나 충돌 보고와 같은 필수 서비스에 사용됩니다.
- **`.shared`**: 싱글톤으로, 처음 요청될 때 온디맨드로 로드됩니다.
- **`.whenNeeded`**: 온디맨드로 로드되며, 기능별 서비스(예: CameraService)에 사용됩니다.
- **`.weak`**: 약한 참조로, 더 이상 사용되지 않을 때 자동으로 할당 해제되어 메모리 누수를 방지합니다.
- **`.transient`**: 요청될 때마다 새로운 인스턴스가 생성됩니다.

이를 통해 앱은 필요할 때 필요한 것만 로드할 수 있습니다.

#### 동시성 및 안전성
이 프레임워크는 최신 Swift 동시성을 염두에 두고 처음부터 구축되었습니다.
- **Actor 기반**: 모든 핵심 구성 요소(`WeaverKernel`, `WeaverContainer`, `WeaverBuilder`, `WeakBox`)는 `actor`이므로 상태에 대한 스레드 안전 접근을 보장합니다.
- **기본적으로 `Sendable`**: 모든 프로토콜과 타입은 `Sendable`이므로 동시성 도메인 간에 안전하게 전달될 수 있습니다.
- **`WeakBox`**: 약한 참조를 안전하게 관리하여 순환 참조와 메모리 누수를 방지하는 커스텀 `actor`입니다.

## 3. SwiftUI 통합

Weaver는 SwiftUI에 대한 일급 지원을 제공합니다.
- **`.weaver(...)` (View Modifier)**: `WeaverContainer`를 뷰 계층에 연결하는 간단한 수정자입니다. 뷰가 나타날 때 컨테이너를 생성하고 사라질 때 종료하는 등 생명주기를 자동으로 관리합니다.
- **미리보기 지원**: `@Dependency`와 `DependencyKey.previewValue`의 조합으로 미리보기를 손쉽게 만들 수 있습니다. DI 시스템은 미리보기 컨텍스트에서 실행될 때 `previewValue`에 정의된 모의 구현을 자동으로 제공합니다.

## 4. iOS 16 마이그레이션 및 정리

최소 배포 대상을 iOS 16으로 지원하기 위한 마이그레이션의 일환으로 다음과 같은 변경 사항이 적용되었습니다:
- **`PlatformAppropriateLock.swift` 제거**: 이 파일은 iOS 15에서 `NSLock`을, iOS 16 이상에서 `OSAllocatedUnfairLock`을 사용하기 위한 호환성 계층을 제공했습니다. 더 이상 iOS 15를 지원하지 않으므로 이 파일은 제거되었으며, 코드베이스는 이제 필요할 때 더 성능이 좋은 `OSAllocatedUnfairLock`을 직접 사용할 수 있습니다(현재 아키텍처에서는 `actor`가 대부분의 잠금을 처리하지만).
