# Weaver DI ì™„ì „ íŠœí† ë¦¬ì–¼

> ğŸ¯ **ì‹¤ìŠµ ì¤‘ì‹¬ í•™ìŠµ** | **ë‹¨ê³„ë³„ ê°€ì´ë“œ** | **ì‹¤ì œ ì•± ê°œë°œ ì‹œë‚˜ë¦¬ì˜¤**

ì´ íŠœí† ë¦¬ì–¼ì€ Weaver DIë¥¼ ì²˜ìŒ ì‚¬ìš©í•˜ëŠ” ê°œë°œìë¶€í„° ê³ ê¸‰ íŒ¨í„´ì„ ë°°ìš°ê³  ì‹¶ì€ ê°œë°œìê¹Œì§€ ëª¨ë“  ë ˆë²¨ì„ ìœ„í•œ ì™„ì „í•œ í•™ìŠµ ê°€ì´ë“œì…ë‹ˆë‹¤.

## ğŸ“‹ í•™ìŠµ ëª©í‘œ

ì´ íŠœí† ë¦¬ì–¼ì„ ì™„ë£Œí•˜ë©´ ë‹¤ìŒì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:
- âœ… Weaver DIì˜ í•µì‹¬ ê°œë… ì´í•´
- âœ… ì‹¤ì œ ì•±ì—ì„œ ì˜ì¡´ì„± ì£¼ì… êµ¬í˜„
- âœ… SwiftUIì™€ UIKitì—ì„œ ì•ˆì „í•˜ê²Œ ì‚¬ìš©
- âœ… í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ ì½”ë“œ ì‘ì„±
- âœ… ì„±ëŠ¥ ìµœì í™” ë° ë©”ëª¨ë¦¬ ê´€ë¦¬
- âœ… ê³ ê¸‰ íŒ¨í„´ ì ìš© (A/B í…ŒìŠ¤íŠ¸, ì¸ì¦ ë“±)

## ğŸ“ ë ˆë²¨ë³„ í•™ìŠµ ê²½ë¡œ

### ğŸŸ¢ ì´ˆê¸‰ (Beginner)
- [1ë‹¨ê³„: ê¸°ë³¸ ê°œë…ê³¼ ì²« ë²ˆì§¸ ì˜ì¡´ì„±](#1ë‹¨ê³„-ê¸°ë³¸-ê°œë…ê³¼-ì²«-ë²ˆì§¸-ì˜ì¡´ì„±)
- [2ë‹¨ê³„: SwiftUIì—ì„œ ì‚¬ìš©í•˜ê¸°](#2ë‹¨ê³„-swiftuiì—ì„œ-ì‚¬ìš©í•˜ê¸°)
- [3ë‹¨ê³„: ëª¨ë“ˆë¡œ ì˜ì¡´ì„± ê·¸ë£¹í™”](#3ë‹¨ê³„-ëª¨ë“ˆë¡œ-ì˜ì¡´ì„±-ê·¸ë£¹í™”)

### ğŸŸ¡ ì¤‘ê¸‰ (Intermediate)  
- [4ë‹¨ê³„: ë„¤íŠ¸ì›Œí¬ ì„œë¹„ìŠ¤ êµ¬í˜„](#4ë‹¨ê³„-ë„¤íŠ¸ì›Œí¬-ì„œë¹„ìŠ¤-êµ¬í˜„)
- [5ë‹¨ê³„: ì—ëŸ¬ ì²˜ë¦¬ì™€ ì•ˆì „ì„±](#5ë‹¨ê³„-ì—ëŸ¬-ì²˜ë¦¬ì™€-ì•ˆì „ì„±)
- [6ë‹¨ê³„: í…ŒìŠ¤íŠ¸ ì‘ì„±í•˜ê¸°](#6ë‹¨ê³„-í…ŒìŠ¤íŠ¸-ì‘ì„±í•˜ê¸°)

### ğŸ”´ ê³ ê¸‰ (Advanced)
- [7ë‹¨ê³„: ì¸ì¦ ì‹œìŠ¤í…œ êµ¬í˜„](#7ë‹¨ê³„-ì¸ì¦-ì‹œìŠ¤í…œ-êµ¬í˜„)
- [8ë‹¨ê³„: ì„±ëŠ¥ ìµœì í™”](#8ë‹¨ê³„-ì„±ëŠ¥-ìµœì í™”)
- [9ë‹¨ê³„: A/B í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œ](#9ë‹¨ê³„-ab-í…ŒìŠ¤íŠ¸-ì‹œìŠ¤í…œ)

---

## ğŸŸ¢ ì´ˆê¸‰ ë ˆë²¨

### 1ë‹¨ê³„: ê¸°ë³¸ ê°œë…ê³¼ ì²« ë²ˆì§¸ ì˜ì¡´ì„±

#### ğŸ¯ í•™ìŠµ ëª©í‘œ
- DependencyKey í”„ë¡œí† ì½œ ì´í•´
- ì²« ë²ˆì§¸ ì„œë¹„ìŠ¤ ë§Œë“¤ê¸°
- @Inject í”„ë¡œí¼í‹° ë˜í¼ ì‚¬ìš©ë²•

#### ğŸ“ ì‹¤ìŠµ: ê°„ë‹¨í•œ ë¡œê±° ì„œë¹„ìŠ¤

**1.1 ì„œë¹„ìŠ¤ í”„ë¡œí† ì½œ ì •ì˜**
```swift
import Weaver

// ë¡œê¹… ê¸°ëŠ¥ì„ ì •ì˜í•˜ëŠ” í”„ë¡œí† ì½œ
protocol Logger: Sendable {
    func info(_ message: String)
    func error(_ message: String)
    func debug(_ message: String)
}
```

**1.2 ì‹¤ì œ êµ¬í˜„ì²´ ë§Œë“¤ê¸°**
```swift
// ì½˜ì†”ì— ë¡œê·¸ë¥¼ ì¶œë ¥í•˜ëŠ” êµ¬í˜„ì²´
final class ConsoleLogger: Logger {
    private let dateFormatter: DateFormatter
    
    init() {
        dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "HH:mm:ss.SSS"
    }
    
    func info(_ message: String) {
        let timestamp = dateFormatter.string(from: Date())
        print("[\(timestamp)] [INFO] \(message)")
    }
    
    func error(_ message: String) {
        let timestamp = dateFormatter.string(from: Date())
        print("[\(timestamp)] [ERROR] \(message)")
    }
    
    func debug(_ message: String) {
        #if DEBUG
        let timestamp = dateFormatter.string(from: Date())
        print("[\(timestamp)] [DEBUG] \(message)")
        #endif
    }
}
```*
*1.3 ì˜ì¡´ì„± í‚¤ ì •ì˜**
```swift
// ì˜ì¡´ì„± í‚¤ - íƒ€ì… ì•ˆì „ì„±ì˜ í•µì‹¬!
struct LoggerKey: DependencyKey {
    typealias Value = Logger
    
    // ğŸ¯ í¬ë˜ì‹œ ë°©ì§€ë¥¼ ìœ„í•œ ì•ˆì „í•œ ê¸°ë³¸ê°’
    static var defaultValue: Logger {
        if WeaverEnvironment.isPreview {
            return PreviewLogger() // Previewìš© ê°„ë‹¨í•œ ë¡œê±°
        } else {
            return ConsoleLogger()
        }
    }
}

// Previewìš© ê°„ë‹¨í•œ ë¡œê±°
struct PreviewLogger: Logger {
    func info(_ message: String) { print("Preview: \(message)") }
    func error(_ message: String) { print("Preview Error: \(message)") }
    func debug(_ message: String) { print("Preview Debug: \(message)") }
}
```

**1.4 ì•±ì—ì„œ ì‚¬ìš©í•˜ê¸°**
```swift
// App.swift
@main
struct TutorialApp: App {
    init() {
        // ì•± ì‹œì‘ ì‹œ DI ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        Task {
            try await Weaver.setup(modules: [LoggingModule()])
        }
    }
    
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}

// ë¡œê¹… ëª¨ë“ˆ
struct LoggingModule: Module {
    func configure(_ builder: WeaverBuilder) async {
        await builder.register(LoggerKey.self, scope: .shared) { _ in
            ConsoleLogger()
        }
    }
}

// ContentView.swift
struct ContentView: View {
    @Inject(LoggerKey.self) private var logger
    
    var body: some View {
        VStack(spacing: 20) {
            Text("Weaver DI íŠœí† ë¦¬ì–¼")
                .font(.title)
            
            Button("ì •ë³´ ë¡œê·¸") {
                Task {
                    let log = await logger()
                    log.info("ì •ë³´ ë²„íŠ¼ì´ í´ë¦­ë˜ì—ˆìŠµë‹ˆë‹¤!")
                }
            }
            
            Button("ì—ëŸ¬ ë¡œê·¸") {
                Task {
                    let log = await logger()
                    log.error("ì—ëŸ¬ ë²„íŠ¼ì´ í´ë¦­ë˜ì—ˆìŠµë‹ˆë‹¤!")
                }
            }
            
            Button("ë””ë²„ê·¸ ë¡œê·¸") {
                Task {
                    let log = await logger()
                    log.debug("ë””ë²„ê·¸ ë²„íŠ¼ì´ í´ë¦­ë˜ì—ˆìŠµë‹ˆë‹¤!")
                }
            }
        }
        .padding()
    }
}
```

**ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤!** ì²« ë²ˆì§¸ ì˜ì¡´ì„± ì£¼ì…ì„ ì„±ê³µì ìœ¼ë¡œ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

#### ğŸ’¡ í•µì‹¬ í¬ì¸íŠ¸
- `DependencyKey`ëŠ” íƒ€ì… ì•ˆì „ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤
- `defaultValue`ëŠ” ì ˆëŒ€ `fatalError()`ë¥¼ ì‚¬ìš©í•˜ì§€ ë§ˆì„¸ìš”
- `@Inject`ì˜ `callAsFunction()`ì€ ì ˆëŒ€ í¬ë˜ì‹œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤
- `scope: .shared`ëŠ” ì‹±ê¸€í†¤ íŒ¨í„´ì…ë‹ˆë‹¤

---

### 2ë‹¨ê³„: SwiftUIì—ì„œ ì‚¬ìš©í•˜ê¸°

#### ğŸ¯ í•™ìŠµ ëª©í‘œ
- SwiftUI Viewì—ì„œ ì•ˆì „í•œ ì˜ì¡´ì„± ì‚¬ìš©
- Previewì—ì„œ Mock ê°ì²´ ì‚¬ìš©
- View ìƒëª…ì£¼ê¸°ì™€ DI ë™ê¸°í™”

#### ğŸ“ ì‹¤ìŠµ: ì‚¬ìš©ì í”„ë¡œí•„ í™”ë©´

**2.1 ì‚¬ìš©ì ëª¨ë¸ ì •ì˜**
```swift
struct User: Codable, Identifiable, Sendable {
    let id: String
    let name: String
    let email: String
    let avatarURL: String?
    
    static let mock = User(
        id: "mock-user",
        name: "ê¹€ì² ìˆ˜",
        email: "kim@example.com",
        avatarURL: nil
    )
}
```

**2.2 ì‚¬ìš©ì ì„œë¹„ìŠ¤ êµ¬í˜„**
```swift
protocol UserService: Sendable {
    func getCurrentUser() async throws -> User?
    func updateProfile(name: String, email: String) async throws
}

// ì‹¤ì œ êµ¬í˜„ì²´ (ë‚˜ì¤‘ì— ë„¤íŠ¸ì›Œí¬ ì—°ë™)
final class APIUserService: UserService {
    @Inject(LoggerKey.self) private var logger
    
    func getCurrentUser() async throws -> User? {
        let log = await logger()
        log.info("ì‚¬ìš©ì ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘...")
        
        // ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•œ ì§€ì—°
        try await Task.sleep(for: .seconds(1))
        
        log.info("ì‚¬ìš©ì ì •ë³´ ë¡œë”© ì™„ë£Œ")
        return User.mock
    }
    
    func updateProfile(name: String, email: String) async throws {
        let log = await logger()
        log.info("í”„ë¡œí•„ ì—…ë°ì´íŠ¸: \(name), \(email)")
        
        // ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•œ ì§€ì—°
        try await Task.sleep(for: .milliseconds(500))
        
        log.info("í”„ë¡œí•„ ì—…ë°ì´íŠ¸ ì™„ë£Œ")
    }
}

// Mock êµ¬í˜„ì²´ (í…ŒìŠ¤íŠ¸/Previewìš©)
final class MockUserService: UserService {
    func getCurrentUser() async throws -> User? {
        return User.mock
    }
    
    func updateProfile(name: String, email: String) async throws {
        print("Mock: í”„ë¡œí•„ ì—…ë°ì´íŠ¸ - \(name), \(email)")
    }
}

// ì˜ì¡´ì„± í‚¤
struct UserServiceKey: DependencyKey {
    typealias Value = UserService
    static var defaultValue: UserService { MockUserService() }
}
```

**2.3 ì‚¬ìš©ì í”„ë¡œí•„ View êµ¬í˜„**
```swift
struct UserProfileView: View {
    @Inject(UserServiceKey.self) private var userService
    @Inject(LoggerKey.self) private var logger
    
    @State private var user: User?
    @State private var isLoading = false
    @State private var errorMessage: String?
    @State private var isEditing = false
    @State private var editName = ""
    @State private var editEmail = ""
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                if isLoading {
                    ProgressView("ì‚¬ìš©ì ì •ë³´ ë¡œë”© ì¤‘...")
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else if let user = user {
                    userInfoView(user)
                } else {
                    Text("ì‚¬ìš©ì ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
                        .foregroundColor(.secondary)
                }
            }
            .navigationTitle("í”„ë¡œí•„")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                if user != nil && !isLoading {
                    Button(isEditing ? "ì™„ë£Œ" : "í¸ì§‘") {
                        if isEditing {
                            Task { await saveProfile() }
                        } else {
                            startEditing()
                        }
                    }
                }
            }
            .alert("ì˜¤ë¥˜", isPresented: .constant(errorMessage != nil)) {
                Button("í™•ì¸") { errorMessage = nil }
            } message: {
                Text(errorMessage ?? "")
            }
        }
        .task {
            await loadUser()
        }
    }
    
    @ViewBuilder
    private func userInfoView(_ user: User) -> some View {
        VStack(spacing: 16) {
            // ì•„ë°”íƒ€
            AsyncImage(url: user.avatarURL.flatMap(URL.init)) { image in
                image
                    .resizable()
                    .aspectRatio(contentMode: .fill)
            } placeholder: {
                Image(systemName: "person.circle.fill")
                    .font(.system(size: 80))
                    .foregroundColor(.gray)
            }
            .frame(width: 100, height: 100)
            .clipShape(Circle())
            
            // ì‚¬ìš©ì ì •ë³´
            if isEditing {
                VStack(spacing: 12) {
                    TextField("ì´ë¦„", text: $editName)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                    
                    TextField("ì´ë©”ì¼", text: $editEmail)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .keyboardType(.emailAddress)
                        .autocapitalization(.none)
                }
                .padding(.horizontal)
            } else {
                VStack(spacing: 8) {
                    Text(user.name)
                        .font(.title2)
                        .fontWeight(.bold)
                    
                    Text(user.email)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
            }
            
            Spacer()
        }
        .padding()
    }
    
    private func loadUser() async {
        isLoading = true
        errorMessage = nil
        defer { isLoading = false }
        
        do {
            let service = await userService()
            user = try await service.getCurrentUser()
            
            let log = await logger()
            log.info("ì‚¬ìš©ì í”„ë¡œí•„ ë¡œë”© ì„±ê³µ")
        } catch {
            errorMessage = error.localizedDescription
            
            let log = await logger()
            log.error("ì‚¬ìš©ì í”„ë¡œí•„ ë¡œë”© ì‹¤íŒ¨: \(error)")
        }
    }
    
    private func startEditing() {
        guard let user = user else { return }
        editName = user.name
        editEmail = user.email
        isEditing = true
    }
    
    private func saveProfile() async {
        guard !editName.isEmpty, !editEmail.isEmpty else {
            errorMessage = "ì´ë¦„ê³¼ ì´ë©”ì¼ì„ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”"
            return
        }
        
        isLoading = true
        defer { isLoading = false }
        
        do {
            let service = await userService()
            try await service.updateProfile(name: editName, email: editEmail)
            
            // ì„±ê³µ ì‹œ ë¡œì»¬ ìƒíƒœ ì—…ë°ì´íŠ¸
            user = User(id: user?.id ?? "", name: editName, email: editEmail, avatarURL: user?.avatarURL)
            isEditing = false
            
            let log = await logger()
            log.info("í”„ë¡œí•„ ì—…ë°ì´íŠ¸ ì„±ê³µ")
        } catch {
            errorMessage = error.localizedDescription
            
            let log = await logger()
            log.error("í”„ë¡œí•„ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: \(error)")
        }
    }
}
```

**2.4 Preview ì„¤ì •**
```swift
#Preview("ê¸°ë³¸ ìƒíƒœ") {
    UserProfileView()
        .weaver(modules: PreviewWeaverContainer.previewModules(
            .register(LoggerKey.self, mockValue: PreviewLogger()),
            .register(UserServiceKey.self, mockValue: MockUserService())
        ))
}

#Preview("ë¡œë”© ìƒíƒœ") {
    UserProfileView()
        .weaver(modules: PreviewWeaverContainer.previewModules(
            .register(LoggerKey.self, mockValue: PreviewLogger()),
            .register(UserServiceKey.self) { _ in
                SlowMockUserService() // ì˜ë„ì ìœ¼ë¡œ ëŠë¦° ì„œë¹„ìŠ¤
            }
        ))
}

// ëŠë¦° Mock ì„œë¹„ìŠ¤ (ë¡œë”© ìƒíƒœ í…ŒìŠ¤íŠ¸ìš©)
final class SlowMockUserService: UserService {
    func getCurrentUser() async throws -> User? {
        try await Task.sleep(for: .seconds(3)) // 3ì´ˆ ì§€ì—°
        return User.mock
    }
    
    func updateProfile(name: String, email: String) async throws {
        try await Task.sleep(for: .seconds(2)) // 2ì´ˆ ì§€ì—°
    }
}
```

**2.5 ëª¨ë“ˆ ì—…ë°ì´íŠ¸**
```swift
struct UserModule: Module {
    func configure(_ builder: WeaverBuilder) async {
        await builder.register(UserServiceKey.self, scope: .shared) { _ in
            APIUserService()
        }
    }
}

// App.swift ì—…ë°ì´íŠ¸
@main
struct TutorialApp: App {
    init() {
        Task {
            try await Weaver.setup(modules: [
                LoggingModule(),
                UserModule()
            ])
        }
    }
    
    var body: some Scene {
        WindowGroup {
            UserProfileView() // ContentView ëŒ€ì‹  UserProfileView ì‚¬ìš©
        }
    }
}
```

#### ğŸ’¡ í•µì‹¬ í¬ì¸íŠ¸
- SwiftUIì—ì„œ `@Inject`ëŠ” `@State`ì™€ í•¨ê»˜ ì‚¬ìš©ë©ë‹ˆë‹¤
- `task` modifierë¡œ View ìƒëª…ì£¼ê¸°ì™€ ë™ê¸°í™”í•©ë‹ˆë‹¤
- Previewì—ì„œëŠ” Mock ê°ì²´ë¥¼ ì‚¬ìš©í•˜ì—¬ ë‹¤ì–‘í•œ ìƒíƒœë¥¼ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤
- ì—ëŸ¬ ì²˜ë¦¬ëŠ” ì‚¬ìš©ì ì¹œí™”ì ìœ¼ë¡œ êµ¬í˜„í•©ë‹ˆë‹¤

---

### 3ë‹¨ê³„: ëª¨ë“ˆë¡œ ì˜ì¡´ì„± ê·¸ë£¹í™”

#### ğŸ¯ í•™ìŠµ ëª©í‘œ
- ê´€ë ¨ ì˜ì¡´ì„±ë“¤ì„ ëª¨ë“ˆë¡œ ê·¸ë£¹í™”
- ëª¨ë“ˆ ê°„ ì˜ì¡´ì„± ê´€ë¦¬
- ìŠ¤ì½”í”„ì˜ ì˜¬ë°”ë¥¸ ì‚¬ìš©ë²•

#### ğŸ“ ì‹¤ìŠµ: ë„¤íŠ¸ì›Œí¬ ëª¨ë“ˆ ì¶”ê°€

**3.1 ë„¤íŠ¸ì›Œí¬ í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„**
```swift
protocol NetworkClient: Sendable {
    func get<T: Codable>(_ endpoint: String) async throws -> T
    func post<T: Codable, U: Codable>(_ endpoint: String, body: T) async throws -> U
}

final class URLSessionNetworkClient: NetworkClient {
    private let baseURL: String
    private let session: URLSession
    
    @Inject(LoggerKey.self) private var logger
    
    init(baseURL: String, session: URLSession = .shared) {
        self.baseURL = baseURL
        self.session = session
    }
    
    func get<T: Codable>(_ endpoint: String) async throws -> T {
        let log = await logger()
        log.info("GET ìš”ì²­: \(endpoint)")
        
        guard let url = URL(string: baseURL + endpoint) else {
            throw NetworkError.invalidURL
        }
        
        let (data, response) = try await session.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse,
              200...299 ~= httpResponse.statusCode else {
            throw NetworkError.serverError
        }
        
        log.info("GET ì‘ë‹µ ì„±ê³µ: \(endpoint)")
        return try JSONDecoder().decode(T.self, from: data)
    }
    
    func post<T: Codable, U: Codable>(_ endpoint: String, body: T) async throws -> U {
        let log = await logger()
        log.info("POST ìš”ì²­: \(endpoint)")
        
        guard let url = URL(string: baseURL + endpoint) else {
            throw NetworkError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try JSONEncoder().encode(body)
        
        let (data, response) = try await session.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              200...299 ~= httpResponse.statusCode else {
            throw NetworkError.serverError
        }
        
        log.info("POST ì‘ë‹µ ì„±ê³µ: \(endpoint)")
        return try JSONDecoder().decode(U.self, from: data)
    }
}

enum NetworkError: Error, LocalizedError {
    case invalidURL
    case serverError
    case noData
    
    var errorDescription: String? {
        switch self {
        case .invalidURL: return "ì˜ëª»ëœ URLì…ë‹ˆë‹¤"
        case .serverError: return "ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤"
        case .noData: return "ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤"
        }
    }
}

struct NetworkClientKey: DependencyKey {
    typealias Value = NetworkClient
    static var defaultValue: NetworkClient {
        MockNetworkClient()
    }
}

// Mock ë„¤íŠ¸ì›Œí¬ í´ë¼ì´ì–¸íŠ¸
final class MockNetworkClient: NetworkClient {
    func get<T: Codable>(_ endpoint: String) async throws -> T {
        // Mock ë°ì´í„° ë°˜í™˜ ë¡œì§
        if T.self == User.self {
            return User.mock as! T
        }
        throw NetworkError.noData
    }
    
    func post<T: Codable, U: Codable>(_ endpoint: String, body: T) async throws -> U {
        // Mock ì‘ë‹µ ë°˜í™˜ ë¡œì§
        if U.self == User.self {
            return User.mock as! U
        }
        throw NetworkError.noData
    }
}
```

**3.2 ë„¤íŠ¸ì›Œí¬ ëª¨ë“ˆ ìƒì„±**
```swift
struct NetworkModule: Module {
    let environment: AppEnvironment
    
    init(environment: AppEnvironment = .development) {
        self.environment = environment
    }
    
    func configure(_ builder: WeaverBuilder) async {
        // í™˜ê²½ë³„ ë² ì´ìŠ¤ URL ì„¤ì •
        let baseURL = switch environment {
        case .production: "https://api.myapp.com"
        case .staging: "https://staging-api.myapp.com"
        case .development: "https://dev-api.myapp.com"
        }
        
        await builder.register(NetworkClientKey.self, scope: .shared) { _ in
            URLSessionNetworkClient(baseURL: baseURL)
        }
    }
}

enum AppEnvironment {
    case production
    case staging
    case development
}
```

**3.3 ì‚¬ìš©ì ì„œë¹„ìŠ¤ ì—…ë°ì´íŠ¸ (ë„¤íŠ¸ì›Œí¬ ì˜ì¡´ì„± ì¶”ê°€)**
```swift
final class APIUserService: UserService {
    @Inject(LoggerKey.self) private var logger
    @Inject(NetworkClientKey.self) private var networkClient
    
    func getCurrentUser() async throws -> User? {
        let log = await logger()
        let client = await networkClient()
        
        log.info("ì‚¬ìš©ì ì •ë³´ API í˜¸ì¶œ ì‹œì‘")
        
        do {
            let user: User = try await client.get("/user/me")
            log.info("ì‚¬ìš©ì ì •ë³´ API í˜¸ì¶œ ì„±ê³µ")
            return user
        } catch {
            log.error("ì‚¬ìš©ì ì •ë³´ API í˜¸ì¶œ ì‹¤íŒ¨: \(error)")
            throw error
        }
    }
    
    func updateProfile(name: String, email: String) async throws {
        let log = await logger()
        let client = await networkClient()
        
        log.info("í”„ë¡œí•„ ì—…ë°ì´íŠ¸ API í˜¸ì¶œ ì‹œì‘")
        
        struct UpdateProfileRequest: Codable {
            let name: String
            let email: String
        }
        
        let request = UpdateProfileRequest(name: name, email: email)
        
        do {
            let _: User = try await client.post("/user/profile", body: request)
            log.info("í”„ë¡œí•„ ì—…ë°ì´íŠ¸ API í˜¸ì¶œ ì„±ê³µ")
        } catch {
            log.error("í”„ë¡œí•„ ì—…ë°ì´íŠ¸ API í˜¸ì¶œ ì‹¤íŒ¨: \(error)")
            throw error
        }
    }
}
```

**3.4 ëª¨ë“ˆ í†µí•©**
```swift
// App.swift ìµœì¢… ì—…ë°ì´íŠ¸
@main
struct TutorialApp: App {
    init() {
        Task {
            try await Weaver.setup(modules: [
                LoggingModule(),           // ë¡œê¹… (ë‹¤ë¥¸ ëª¨ë“ˆë“¤ì´ ì˜ì¡´)
                NetworkModule(),           // ë„¤íŠ¸ì›Œí¬ (ì‚¬ìš©ì ëª¨ë“ˆì´ ì˜ì¡´)
                UserModule()               // ì‚¬ìš©ì (ë„¤íŠ¸ì›Œí¬ì™€ ë¡œê¹…ì— ì˜ì¡´)
            ])
        }
    }
    
    var body: some Scene {
        WindowGroup {
            UserProfileView()
        }
    }
}
```

#### ğŸ’¡ í•µì‹¬ í¬ì¸íŠ¸
- ëª¨ë“ˆì€ ê´€ë ¨ ì˜ì¡´ì„±ë“¤ì„ ë…¼ë¦¬ì ìœ¼ë¡œ ê·¸ë£¹í™”í•©ë‹ˆë‹¤
- ëª¨ë“ˆ ê°„ ì˜ì¡´ì„± ìˆœì„œê°€ ì¤‘ìš”í•©ë‹ˆë‹¤ (ë¡œê¹… â†’ ë„¤íŠ¸ì›Œí¬ â†’ ì‚¬ìš©ì)
- í™˜ê²½ë³„ ì„¤ì •ì„ ëª¨ë“ˆì—ì„œ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
- `scope: .shared`ëŠ” ì•± ì „ì²´ì—ì„œ í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê³µìœ í•©ë‹ˆë‹¤

#### ğŸ’¡ ìŠ¤ì½”í”„ ì™„ì „ ê°€ì´ë“œ

WeaverëŠ” 5ê°€ì§€ ì§ê´€ì ì¸ ìŠ¤ì½”í”„ë¥¼ ì œê³µí•©ë‹ˆë‹¤:

```swift
// ğŸ”„ .shared: ì•± ì „ì²´ì—ì„œ í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤ ê³µìœ  (ì‹±ê¸€í†¤)
await builder.register(DatabaseKey.self, scope: .shared) { _ in
    CoreDataManager()
}

// ğŸ§¹ .weak: ì•½í•œ ì°¸ì¡°ë¡œ ë©”ëª¨ë¦¬ íš¨ìœ¨ ê´€ë¦¬
await builder.registerWeak(ImageCacheKey.self) { _ in
    ImageCache()
}

// ğŸš€ .startup: ì•± ì‹œì‘ ì‹œ ì¦‰ì‹œ ë¡œë”© (í•„ìˆ˜ ì„œë¹„ìŠ¤)
await builder.register(LoggerKey.self, scope: .startup) { _ in
    ProductionLogger()
}

// ğŸ’¤ .whenNeeded: ì‹¤ì œ ì‚¬ìš©í•  ë•Œë§Œ ë¡œë”© (ì§€ì—° ë¡œë”©)
await builder.register(CameraServiceKey.self, scope: .whenNeeded) { _ in
    CameraService()
}

// ğŸ”„ .transient: ë§¤ë²ˆ ìƒˆë¡œìš´ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± (ì¼íšŒì„±)
await builder.register(DataProcessorKey.self, scope: .transient) { _ in
    DataProcessor()
}
```

**ğŸ‰ ì´ˆê¸‰ ë ˆë²¨ ì™„ë£Œ!** ì´ì œ Weaver DIì˜ ê¸°ë³¸ ê°œë…ì„ ì™„ì „íˆ ì´í•´í–ˆìŠµë‹ˆë‹¤.

---

## ğŸŸ¡ ì¤‘ê¸‰ ë ˆë²¨

### 4ë‹¨ê³„: ë„¤íŠ¸ì›Œí¬ ì„œë¹„ìŠ¤ êµ¬í˜„

#### ğŸ¯ í•™ìŠµ ëª©í‘œ
- ì‹¤ì œ ë„¤íŠ¸ì›Œí¬ í†µì‹  êµ¬í˜„
- ì—ëŸ¬ ì²˜ë¦¬ ë° ì¬ì‹œë„ ë¡œì§
- ìºì‹± ì‹œìŠ¤í…œ êµ¬ì¶•

#### ğŸ“ ì‹¤ìŠµ: ì™„ì „í•œ ë„¤íŠ¸ì›Œí¬ ìŠ¤íƒ

**4.1 ê³ ê¸‰ ë„¤íŠ¸ì›Œí¬ í´ë¼ì´ì–¸íŠ¸**
```swift
// ë„¤íŠ¸ì›Œí¬ ì„¤ì •
struct NetworkConfiguration {
    let baseURL: String
    let timeout: TimeInterval
    let retryCount: Int
    let cachePolicy: URLRequest.CachePolicy
    
    static let `default` = NetworkConfiguration(
        baseURL: "https://jsonplaceholder.typicode.com",
        timeout: 30.0,
        retryCount: 3,
        cachePolicy: .useProtocolCachePolicy
    )
}

// ê³ ê¸‰ ë„¤íŠ¸ì›Œí¬ í´ë¼ì´ì–¸íŠ¸
final class AdvancedNetworkClient: NetworkClient {
    private let configuration: NetworkConfiguration
    private let session: URLSession
    
    @Inject(LoggerKey.self) private var logger
    
    init(configuration: NetworkConfiguration = .default) {
        self.configuration = configuration
        
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = configuration.timeout
        config.requestCachePolicy = configuration.cachePolicy
        
        self.session = URLSession(configuration: config)
    }
    
    func get<T: Codable>(_ endpoint: String) async throws -> T {
        return try await performRequest(endpoint: endpoint, method: "GET", body: nil as String?)
    }
    
    func post<T: Codable, U: Codable>(_ endpoint: String, body: T) async throws -> U {
        return try await performRequest(endpoint: endpoint, method: "POST", body: body)
    }
    
    private func performRequest<T: Codable, U: Codable>(
        endpoint: String,
        method: String,
        body: T?
    ) async throws -> U {
        let log = await logger()
        
        for attempt in 1...configuration.retryCount {
            do {
                log.info("\(method) ìš”ì²­ ì‹œë„ \(attempt)/\(configuration.retryCount): \(endpoint)")
                
                guard let url = URL(string: configuration.baseURL + endpoint) else {
                    throw NetworkError.invalidURL
                }
                
                var request = URLRequest(url: url)
                request.httpMethod = method
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                
                if let body = body {
                    request.httpBody = try JSONEncoder().encode(body)
                }
                
                let (data, response) = try await session.data(for: request)
                
                guard let httpResponse = response as? HTTPURLResponse else {
                    throw NetworkError.invalidResponse
                }
                
                switch httpResponse.statusCode {
                case 200...299:
                    log.info("\(method) ìš”ì²­ ì„±ê³µ: \(endpoint)")
                    return try JSONDecoder().decode(U.self, from: data)
                case 400...499:
                    throw NetworkError.clientError(httpResponse.statusCode)
                case 500...599:
                    throw NetworkError.serverError(httpResponse.statusCode)
                default:
                    throw NetworkError.unknownError(httpResponse.statusCode)
                }
                
            } catch {
                log.error("\(method) ìš”ì²­ ì‹¤íŒ¨ (ì‹œë„ \(attempt)): \(error)")
                
                // ë§ˆì§€ë§‰ ì‹œë„ê°€ ì•„ë‹ˆë©´ ì¬ì‹œë„
                if attempt < configuration.retryCount {
                    let delay = TimeInterval(attempt * attempt) // ì§€ìˆ˜ ë°±ì˜¤í”„
                    try await Task.sleep(for: .seconds(delay))
                    continue
                } else {
                    throw error
                }
            }
        }
        
        throw NetworkError.maxRetriesExceeded
    }
}

// í™•ì¥ëœ ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬
enum NetworkError: Error, LocalizedError {
    case invalidURL
    case invalidResponse
    case clientError(Int)
    case serverError(Int)
    case unknownError(Int)
    case maxRetriesExceeded
    case decodingError(Error)
    
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "ì˜ëª»ëœ URLì…ë‹ˆë‹¤"
        case .invalidResponse:
            return "ì˜ëª»ëœ ì‘ë‹µì…ë‹ˆë‹¤"
        case .clientError(let code):
            return "í´ë¼ì´ì–¸íŠ¸ ì˜¤ë¥˜ (ì½”ë“œ: \(code))"
        case .serverError(let code):
            return "ì„œë²„ ì˜¤ë¥˜ (ì½”ë“œ: \(code))"
        case .unknownError(let code):
            return "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ (ì½”ë“œ: \(code))"
        case .maxRetriesExceeded:
            return "ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤"
        case .decodingError(let error):
            return "ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜: \(error.localizedDescription)"
        }
    }
}
```

ì´ì œ íŠœí† ë¦¬ì–¼ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì„ ê³„ì† ì‘ì„±í•˜ê² ìŠµë‹ˆë‹¤.**4.2 ìºì‹±
 ì‹œìŠ¤í…œ êµ¬í˜„**
```swift
// ìºì‹œ ì •ì±…
enum CachePolicy {
    case noCache
    case memoryOnly(maxSize: Int)
    case diskAndMemory(maxSize: Int, diskSize: Int)
    case custom(TimeInterval) // ì»¤ìŠ¤í…€ ë§Œë£Œ ì‹œê°„
}

// ì‘ë‹µ ìºì‹œ ë§¤ë‹ˆì €
final class ResponseCacheManager: Sendable {
    private let memoryCache = NSCache<NSString, NSData>()
    private let cachePolicy: CachePolicy
    
    @Inject(LoggerKey.self) private var logger
    
    init(policy: CachePolicy = .memoryOnly(maxSize: 100)) {
        self.cachePolicy = policy
        
        switch policy {
        case .memoryOnly(let maxSize), .diskAndMemory(let maxSize, _):
            memoryCache.countLimit = maxSize
        default:
            break
        }
    }
    
    func get<T: Codable>(_ key: String, type: T.Type) async -> T? {
        let log = await logger()
        
        guard case .noCache = cachePolicy else {
            return nil
        }
        
        if let data = memoryCache.object(forKey: key as NSString) {
            do {
                let object = try JSONDecoder().decode(T.self, from: data as Data)
                log.debug("ìºì‹œ íˆíŠ¸: \(key)")
                return object
            } catch {
                log.error("ìºì‹œ ë””ì½”ë”© ì‹¤íŒ¨: \(error)")
                memoryCache.removeObject(forKey: key as NSString)
            }
        }
        
        log.debug("ìºì‹œ ë¯¸ìŠ¤: \(key)")
        return nil
    }
    
    func set<T: Codable>(_ key: String, value: T) async {
        let log = await logger()
        
        guard case .noCache = cachePolicy else {
            return
        }
        
        do {
            let data = try JSONEncoder().encode(value)
            memoryCache.setObject(data as NSData, forKey: key as NSString)
            log.debug("ìºì‹œ ì €ì¥: \(key)")
        } catch {
            log.error("ìºì‹œ ì¸ì½”ë”© ì‹¤íŒ¨: \(error)")
        }
    }
    
    func clear() async {
        memoryCache.removeAllObjects()
        let log = await logger()
        log.info("ìºì‹œ ì „ì²´ ì‚­ì œ")
    }
}

struct ResponseCacheManagerKey: DependencyKey {
    typealias Value = ResponseCacheManager
    static var defaultValue: ResponseCacheManager {
        ResponseCacheManager(policy: .memoryOnly(maxSize: 50))
    }
}
```

**4.3 ìºì‹œëœ ë„¤íŠ¸ì›Œí¬ ì„œë¹„ìŠ¤**
```swift
final class CachedNetworkService: Sendable {
    @Inject(NetworkClientKey.self) private var networkClient
    @Inject(ResponseCacheManagerKey.self) private var cacheManager
    @Inject(LoggerKey.self) private var logger
    
    func getCachedData<T: Codable>(
        _ endpoint: String,
        type: T.Type,
        cacheKey: String? = nil,
        forceRefresh: Bool = false
    ) async throws -> T {
        let key = cacheKey ?? "cached_\(endpoint)"
        let log = await logger()
        
        // ê°•ì œ ìƒˆë¡œê³ ì¹¨ì´ ì•„ë‹ˆë©´ ìºì‹œ í™•ì¸
        if !forceRefresh {
            let cache = await cacheManager()
            if let cachedData = await cache.get(key, type: T.self) {
                log.info("ìºì‹œì—ì„œ ë°ì´í„° ë°˜í™˜: \(endpoint)")
                return cachedData
            }
        }
        
        // ìºì‹œ ë¯¸ìŠ¤ ë˜ëŠ” ê°•ì œ ìƒˆë¡œê³ ì¹¨ ì‹œ ë„¤íŠ¸ì›Œí¬ ìš”ì²­
        let client = await networkClient()
        let data: T = try await client.get(endpoint)
        
        // ì‘ë‹µì„ ìºì‹œì— ì €ì¥
        let cache = await cacheManager()
        await cache.set(key, value: data)
        
        log.info("ë„¤íŠ¸ì›Œí¬ì—ì„œ ë°ì´í„° ê°€ì ¸ì™€ì„œ ìºì‹œ ì €ì¥: \(endpoint)")
        return data
    }
    
    func postWithCache<T: Codable, U: Codable>(
        _ endpoint: String,
        body: T,
        responseType: U.Type,
        invalidateCacheKeys: [String] = []
    ) async throws -> U {
        let client = await networkClient()
        let response: U = try await client.post(endpoint, body: body)
        
        // POST ì„±ê³µ ì‹œ ê´€ë ¨ ìºì‹œ ë¬´íš¨í™”
        if !invalidateCacheKeys.isEmpty {
            let cache = await cacheManager()
            let log = await logger()
            
            for key in invalidateCacheKeys {
                // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” íŠ¹ì • í‚¤ë§Œ ì‚­ì œí•˜ëŠ” ë©”ì„œë“œ í•„ìš”
                log.info("ìºì‹œ ë¬´íš¨í™”: \(key)")
            }
        }
        
        return response
    }
}

struct CachedNetworkServiceKey: DependencyKey {
    typealias Value = CachedNetworkService
    static var defaultValue: CachedNetworkService { CachedNetworkService() }
}
```

**4.4 ì—…ë°ì´íŠ¸ëœ ë„¤íŠ¸ì›Œí¬ ëª¨ë“ˆ**
```swift
struct NetworkModule: Module {
    let environment: AppEnvironment
    let cachePolicy: CachePolicy
    
    init(environment: AppEnvironment = .development, cachePolicy: CachePolicy = .memoryOnly(maxSize: 100)) {
        self.environment = environment
        self.cachePolicy = cachePolicy
    }
    
    func configure(_ builder: WeaverBuilder) async {
        // ë„¤íŠ¸ì›Œí¬ ì„¤ì •
        let config = NetworkConfiguration(
            baseURL: environment.baseURL,
            timeout: 30.0,
            retryCount: environment == .production ? 3 : 1,
            cachePolicy: .useProtocolCachePolicy
        )
        
        // ê¸°ë³¸ ë„¤íŠ¸ì›Œí¬ í´ë¼ì´ì–¸íŠ¸
        await builder.register(NetworkClientKey.self, scope: .shared) { _ in
            AdvancedNetworkClient(configuration: config)
        }
        
        // ìºì‹œ ë§¤ë‹ˆì €
        await builder.register(ResponseCacheManagerKey.self, scope: .shared) { _ in
            ResponseCacheManager(policy: cachePolicy)
        }
        
        // ìºì‹œëœ ë„¤íŠ¸ì›Œí¬ ì„œë¹„ìŠ¤
        await builder.register(CachedNetworkServiceKey.self, scope: .shared) { _ in
            CachedNetworkService()
        }
    }
}

extension AppEnvironment {
    var baseURL: String {
        switch self {
        case .production: return "https://api.myapp.com"
        case .staging: return "https://staging-api.myapp.com"
        case .development: return "https://jsonplaceholder.typicode.com"
        }
    }
}
```

**4.5 ì‚¬ìš©ì ì„œë¹„ìŠ¤ ìµœì¢… ì—…ë°ì´íŠ¸**
```swift
final class APIUserService: UserService {
    @Inject(CachedNetworkServiceKey.self) private var cachedNetworkService
    @Inject(LoggerKey.self) private var logger
    
    func getCurrentUser() async throws -> User? {
        let log = await logger()
        log.info("ì‚¬ìš©ì ì •ë³´ ìš”ì²­ ì‹œì‘")
        
        do {
            let service = await cachedNetworkService()
            // JSONPlaceholder API ì‚¬ìš© (ì‹¤ì œ ì•±ì—ì„œëŠ” /user/me)
            let user = try await service.getCachedData("/users/1", type: User.self)
            
            log.info("ì‚¬ìš©ì ì •ë³´ ìš”ì²­ ì„±ê³µ")
            return user
        } catch {
            log.error("ì‚¬ìš©ì ì •ë³´ ìš”ì²­ ì‹¤íŒ¨: \(error)")
            throw error
        }
    }
    
    func updateProfile(name: String, email: String) async throws {
        let log = await logger()
        log.info("í”„ë¡œí•„ ì—…ë°ì´íŠ¸ ìš”ì²­ ì‹œì‘")
        
        struct UpdateRequest: Codable {
            let name: String
            let email: String
        }
        
        do {
            let service = await cachedNetworkService()
            let request = UpdateRequest(name: name, email: email)
            
            // í”„ë¡œí•„ ì—…ë°ì´íŠ¸ í›„ ì‚¬ìš©ì ì •ë³´ ìºì‹œ ë¬´íš¨í™”
            let _: User = try await service.postWithCache(
                "/users/1",
                body: request,
                responseType: User.self,
                invalidateCacheKeys: ["cached_/users/1"]
            )
            
            log.info("í”„ë¡œí•„ ì—…ë°ì´íŠ¸ ì„±ê³µ")
        } catch {
            log.error("í”„ë¡œí•„ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: \(error)")
            throw error
        }
    }
}
```

#### ğŸ’¡ í•µì‹¬ í¬ì¸íŠ¸
- ë„¤íŠ¸ì›Œí¬ í´ë¼ì´ì–¸íŠ¸ëŠ” ì¬ì‹œë„ ë¡œì§ê³¼ ì§€ìˆ˜ ë°±ì˜¤í”„ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤
- ìºì‹± ì‹œìŠ¤í…œìœ¼ë¡œ ì„±ëŠ¥ì„ í¬ê²Œ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤
- POST ìš”ì²­ í›„ ê´€ë ¨ ìºì‹œë¥¼ ë¬´íš¨í™”í•˜ì—¬ ë°ì´í„° ì¼ê´€ì„±ì„ ìœ ì§€í•©ë‹ˆë‹¤
- í™˜ê²½ë³„ë¡œ ë‹¤ë¥¸ ì„¤ì •ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

---

### 5ë‹¨ê³„: ì—ëŸ¬ ì²˜ë¦¬ì™€ ì•ˆì „ì„±

#### ğŸ¯ í•™ìŠµ ëª©í‘œ
- êµ¬ì¡°í™”ëœ ì—ëŸ¬ ì²˜ë¦¬ ì‹œìŠ¤í…œ
- ì‚¬ìš©ì ì¹œí™”ì  ì—ëŸ¬ ë©”ì‹œì§€
- ì—ëŸ¬ ë³µêµ¬ ì „ëµ

#### ğŸ“ ì‹¤ìŠµ: ì™„ì „í•œ ì—ëŸ¬ ì²˜ë¦¬ ì‹œìŠ¤í…œ

**5.1 ì•± ì „ì²´ ì—ëŸ¬ íƒ€ì… ì •ì˜**
```swift
// ì•± ë ˆë²¨ ì—ëŸ¬
enum AppError: Error, LocalizedError {
    case network(NetworkError)
    case user(UserError)
    case cache(CacheError)
    case unknown(Error)
    
    var errorDescription: String? {
        switch self {
        case .network(let error):
            return "ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: \(error.localizedDescription)"
        case .user(let error):
            return "ì‚¬ìš©ì ì˜¤ë¥˜: \(error.localizedDescription)"
        case .cache(let error):
            return "ìºì‹œ ì˜¤ë¥˜: \(error.localizedDescription)"
        case .unknown(let error):
            return "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜: \(error.localizedDescription)"
        }
    }
    
    var recoverySuggestion: String? {
        switch self {
        case .network(.maxRetriesExceeded):
            return "ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•˜ê³  ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
        case .network(.serverError):
            return "ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
        case .user(.invalidInput):
            return "ì…ë ¥ ì •ë³´ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”."
        default:
            return "ì•±ì„ ë‹¤ì‹œ ì‹œì‘í•´ë³´ì„¸ìš”."
        }
    }
}

// ì‚¬ìš©ì ê´€ë ¨ ì—ëŸ¬
enum UserError: Error, LocalizedError {
    case notFound
    case invalidInput
    case unauthorized
    case profileUpdateFailed
    
    var errorDescription: String? {
        switch self {
        case .notFound:
            return "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
        case .invalidInput:
            return "ì…ë ¥ ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤"
        case .unauthorized:
            return "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤"
        case .profileUpdateFailed:
            return "í”„ë¡œí•„ ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤"
        }
    }
}

// ìºì‹œ ê´€ë ¨ ì—ëŸ¬
enum CacheError: Error, LocalizedError {
    case encodingFailed
    case decodingFailed
    case storageError
    
    var errorDescription: String? {
        switch self {
        case .encodingFailed:
            return "ë°ì´í„° ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤"
        case .decodingFailed:
            return "ë°ì´í„° ì½ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤"
        case .storageError:
            return "ì €ì¥ì†Œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤"
        }
    }
}
```

**5.2 ì—ëŸ¬ ì²˜ë¦¬ ì„œë¹„ìŠ¤**
```swift
protocol ErrorHandlingService: Sendable {
    func handleError(_ error: Error) async -> AppError
    func shouldRetry(_ error: AppError) -> Bool
    func getRetryDelay(_ error: AppError, attempt: Int) -> TimeInterval
}

final class DefaultErrorHandlingService: ErrorHandlingService {
    @Inject(LoggerKey.self) private var logger
    
    func handleError(_ error: Error) async -> AppError {
        let log = await logger()
        
        let appError: AppError
        
        switch error {
        case let networkError as NetworkError:
            appError = .network(networkError)
        case let userError as UserError:
            appError = .user(userError)
        case let cacheError as CacheError:
            appError = .cache(cacheError)
        default:
            appError = .unknown(error)
        }
        
        log.error("ì—ëŸ¬ ì²˜ë¦¬: \(appError.localizedDescription)")
        return appError
    }
    
    func shouldRetry(_ error: AppError) -> Bool {
        switch error {
        case .network(.serverError), .network(.unknownError):
            return true
        case .cache(.storageError):
            return true
        default:
            return false
        }
    }
    
    func getRetryDelay(_ error: AppError, attempt: Int) -> TimeInterval {
        // ì§€ìˆ˜ ë°±ì˜¤í”„: 1ì´ˆ, 2ì´ˆ, 4ì´ˆ, 8ì´ˆ...
        return TimeInterval(min(pow(2.0, Double(attempt)), 30.0))
    }
}

struct ErrorHandlingServiceKey: DependencyKey {
    typealias Value = ErrorHandlingService
    static var defaultValue: ErrorHandlingService { DefaultErrorHandlingService() }
}
```

**5.3 ì—ëŸ¬ ë³µêµ¬ ê°€ëŠ¥í•œ ì‚¬ìš©ì ì„œë¹„ìŠ¤**
```swift
final class ResilientUserService: UserService {
    @Inject(CachedNetworkServiceKey.self) private var cachedNetworkService
    @Inject(ErrorHandlingServiceKey.self) private var errorHandlingService
    @Inject(LoggerKey.self) private var logger
    
    private let maxRetryAttempts = 3
    
    func getCurrentUser() async throws -> User? {
        return try await performWithRetry { [weak self] in
            guard let self = self else { throw UserError.notFound }
            
            let service = await self.cachedNetworkService()
            return try await service.getCachedData("/users/1", type: User.self)
        }
    }
    
    func updateProfile(name: String, email: String) async throws {
        // ì…ë ¥ ê²€ì¦
        guard !name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            throw UserError.invalidInput
        }
        
        guard email.contains("@") && email.contains(".") else {
            throw UserError.invalidInput
        }
        
        struct UpdateRequest: Codable {
            let name: String
            let email: String
        }
        
        let request = UpdateRequest(name: name, email: email)
        
        let _: User = try await performWithRetry { [weak self] in
            guard let self = self else { throw UserError.profileUpdateFailed }
            
            let service = await self.cachedNetworkService()
            return try await service.postWithCache(
                "/users/1",
                body: request,
                responseType: User.self,
                invalidateCacheKeys: ["cached_/users/1"]
            )
        }
    }
    
    private func performWithRetry<T>(
        operation: @escaping () async throws -> T
    ) async throws -> T {
        let log = await logger()
        let errorHandler = await errorHandlingService()
        
        for attempt in 1...maxRetryAttempts {
            do {
                return try await operation()
            } catch {
                let appError = await errorHandler.handleError(error)
                
                // ë§ˆì§€ë§‰ ì‹œë„ì´ê±°ë‚˜ ì¬ì‹œë„ ë¶ˆê°€ëŠ¥í•œ ì—ëŸ¬ë©´ ë˜ì§€ê¸°
                if attempt == maxRetryAttempts || !errorHandler.shouldRetry(appError) {
                    log.error("ìµœì¢… ì‹¤íŒ¨ (ì‹œë„ \(attempt)/\(maxRetryAttempts)): \(appError)")
                    throw appError
                }
                
                // ì¬ì‹œë„ ëŒ€ê¸°
                let delay = errorHandler.getRetryDelay(appError, attempt: attempt)
                log.info("ì¬ì‹œë„ ëŒ€ê¸° \(delay)ì´ˆ (ì‹œë„ \(attempt)/\(maxRetryAttempts))")
                
                try await Task.sleep(for: .seconds(delay))
            }
        }
        
        throw UserError.profileUpdateFailed
    }
}
```

**5.4 ì—ëŸ¬ í‘œì‹œ UI ì»´í¬ë„ŒíŠ¸**
```swift
// ì—ëŸ¬ ìƒíƒœë¥¼ ê´€ë¦¬í•˜ëŠ” ObservableObject
@MainActor
class ErrorViewModel: ObservableObject {
    @Published var currentError: AppError?
    @Published var isShowingError = false
    
    @Inject(ErrorHandlingServiceKey.self) private var errorHandlingService
    @Inject(LoggerKey.self) private var logger
    
    func handleError(_ error: Error) async {
        let handler = await errorHandlingService()
        let appError = await handler.handleError(error)
        
        await MainActor.run {
            self.currentError = appError
            self.isShowingError = true
        }
    }
    
    func dismissError() {
        currentError = nil
        isShowingError = false
    }
    
    func canRetry() -> Bool {
        guard let error = currentError else { return false }
        
        Task {
            let handler = await errorHandlingService()
            return handler.shouldRetry(error)
        }
        
        return false
    }
}

// ì—ëŸ¬ í‘œì‹œ View
struct ErrorView: View {
    let error: AppError
    let onRetry: (() -> Void)?
    let onDismiss: () -> Void
    
    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: "exclamationmark.triangle")
                .font(.system(size: 50))
                .foregroundColor(.red)
            
            Text("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤")
                .font(.title2)
                .fontWeight(.bold)
            
            Text(error.localizedDescription)
                .font(.body)
                .multilineTextAlignment(.center)
                .foregroundColor(.secondary)
            
            if let suggestion = error.recoverySuggestion {
                Text(suggestion)
                    .font(.caption)
                    .multilineTextAlignment(.center)
                    .foregroundColor(.secondary)
                    .padding(.horizontal)
            }
            
            HStack(spacing: 12) {
                Button("í™•ì¸") {
                    onDismiss()
                }
                .buttonStyle(.bordered)
                
                if let onRetry = onRetry {
                    Button("ë‹¤ì‹œ ì‹œë„") {
                        onRetry()
                    }
                    .buttonStyle(.borderedProminent)
                }
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 10)
    }
}
```

**5.5 ì—ëŸ¬ ì²˜ë¦¬ê°€ í†µí•©ëœ ì‚¬ìš©ì í”„ë¡œí•„ View**
```swift
struct ResilientUserProfileView: View {
    @StateObject private var errorViewModel = ErrorViewModel()
    @Inject(UserServiceKey.self) private var userService
    
    @State private var user: User?
    @State private var isLoading = false
    @State private var isEditing = false
    @State private var editName = ""
    @State private var editEmail = ""
    
    var body: some View {
        NavigationView {
            ZStack {
                VStack(spacing: 20) {
                    if isLoading {
                        ProgressView("ë¡œë”© ì¤‘...")
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                    } else if let user = user {
                        userInfoView(user)
                    } else {
                        emptyStateView()
                    }
                }
                .navigationTitle("í”„ë¡œí•„")
                .toolbar {
                    if user != nil && !isLoading {
                        Button(isEditing ? "ì™„ë£Œ" : "í¸ì§‘") {
                            if isEditing {
                                Task { await saveProfile() }
                            } else {
                                startEditing()
                            }
                        }
                    }
                }
                
                // ì—ëŸ¬ ì˜¤ë²„ë ˆì´
                if errorViewModel.isShowingError {
                    Color.black.opacity(0.3)
                        .ignoresSafeArea()
                        .onTapGesture {
                            errorViewModel.dismissError()
                        }
                    
                    if let error = errorViewModel.currentError {
                        ErrorView(
                            error: error,
                            onRetry: errorViewModel.canRetry() ? {
                                errorViewModel.dismissError()
                                Task { await loadUser() }
                            } : nil,
                            onDismiss: {
                                errorViewModel.dismissError()
                            }
                        )
                        .padding()
                    }
                }
            }
        }
        .task {
            await loadUser()
        }
    }
    
    @ViewBuilder
    private func userInfoView(_ user: User) -> some View {
        VStack(spacing: 16) {
            // ì•„ë°”íƒ€
            AsyncImage(url: user.avatarURL.flatMap(URL.init)) { image in
                image
                    .resizable()
                    .aspectRatio(contentMode: .fill)
            } placeholder: {
                Image(systemName: "person.circle.fill")
                    .font(.system(size: 80))
                    .foregroundColor(.gray)
            }
            .frame(width: 100, height: 100)
            .clipShape(Circle())
            
            // ì‚¬ìš©ì ì •ë³´
            if isEditing {
                VStack(spacing: 12) {
                    TextField("ì´ë¦„", text: $editName)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                    
                    TextField("ì´ë©”ì¼", text: $editEmail)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .keyboardType(.emailAddress)
                        .autocapitalization(.none)
                }
                .padding(.horizontal)
            } else {
                VStack(spacing: 8) {
                    Text(user.name)
                        .font(.title2)
                        .fontWeight(.bold)
                    
                    Text(user.email)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
            }
            
            Spacer()
        }
        .padding()
    }
    
    @ViewBuilder
    private func emptyStateView() -> some View {
        VStack(spacing: 16) {
            Image(systemName: "person.slash")
                .font(.system(size: 60))
                .foregroundColor(.gray)
            
            Text("ì‚¬ìš©ì ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
                .font(.title3)
                .foregroundColor(.secondary)
            
            Button("ë‹¤ì‹œ ì‹œë„") {
                Task { await loadUser() }
            }
            .buttonStyle(.borderedProminent)
        }
    }
    
    private func loadUser() async {
        isLoading = true
        defer { isLoading = false }
        
        do {
            let service = await userService()
            user = try await service.getCurrentUser()
        } catch {
            await errorViewModel.handleError(error)
        }
    }
    
    private func startEditing() {
        guard let user = user else { return }
        editName = user.name
        editEmail = user.email
        isEditing = true
    }
    
    private func saveProfile() async {
        isLoading = true
        defer { isLoading = false }
        
        do {
            let service = await userService()
            try await service.updateProfile(name: editName, email: editEmail)
            
            // ì„±ê³µ ì‹œ ë¡œì»¬ ìƒíƒœ ì—…ë°ì´íŠ¸
            user = User(id: user?.id ?? "", name: editName, email: editEmail, avatarURL: user?.avatarURL)
            isEditing = false
        } catch {
            await errorViewModel.handleError(error)
        }
    }
}
```

**5.6 ì—ëŸ¬ ì²˜ë¦¬ ëª¨ë“ˆ**
```swift
struct ErrorHandlingModule: Module {
    func configure(_ builder: WeaverBuilder) async {
        await builder.register(ErrorHandlingServiceKey.self, scope: .shared) { _ in
            DefaultErrorHandlingService()
        }
    }
}

// ì‚¬ìš©ì ëª¨ë“ˆ ì—…ë°ì´íŠ¸
struct UserModule: Module {
    func configure(_ builder: WeaverBuilder) async {
        await builder.register(UserServiceKey.self, scope: .shared) { _ in
            ResilientUserService() // ì—ëŸ¬ ë³µêµ¬ ê°€ëŠ¥í•œ ì„œë¹„ìŠ¤ë¡œ ë³€ê²½
        }
    }
}
```

#### ğŸ’¡ í•µì‹¬ í¬ì¸íŠ¸
- êµ¬ì¡°í™”ëœ ì—ëŸ¬ íƒ€ì…ìœ¼ë¡œ ëª…í™•í•œ ì—ëŸ¬ ì²˜ë¦¬
- ìë™ ì¬ì‹œë„ ë¡œì§ìœ¼ë¡œ ì¼ì‹œì  ì˜¤ë¥˜ í•´ê²°
- ì‚¬ìš©ì ì¹œí™”ì ì¸ ì—ëŸ¬ ë©”ì‹œì§€ì™€ ë³µêµ¬ ì œì•ˆ
- ì—ëŸ¬ ìƒíƒœë¥¼ ë³„ë„ ViewModelë¡œ ê´€ë¦¬í•˜ì—¬ ì¬ì‚¬ìš©ì„± í–¥ìƒ

---

### 6ë‹¨ê³„: í…ŒìŠ¤íŠ¸ ì‘ì„±í•˜ê¸°

#### ğŸ¯ í•™ìŠµ ëª©í‘œ
- ì˜ì¡´ì„± ì£¼ì…ì„ í™œìš©í•œ í…ŒìŠ¤íŠ¸ ì‘ì„±
- Mock ê°ì²´ ìƒì„± ë° ì‚¬ìš©
- ê²©ë¦¬ëœ í…ŒìŠ¤íŠ¸ í™˜ê²½ êµ¬ì¶•

#### ğŸ“ ì‹¤ìŠµ: ì™„ì „í•œ í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸

**6.1 í…ŒìŠ¤íŠ¸ìš© Mock ì„œë¹„ìŠ¤ë“¤**
```swift
// Tests/TutorialTests/Mocks/MockServices.swift
import XCTest
@testable import Tutorial
import Weaver

// Mock ë¡œê±°
final class MockLogger: Logger {
    private(set) var infoMessages: [String] = []
    private(set) var errorMessages: [String] = []
    private(set) var debugMessages: [String] = []
    
    func info(_ message: String) {
        infoMessages.append(message)
    }
    
    func error(_ message: String) {
        errorMessages.append(message)
    }
    
    func debug(_ message: String) {
        debugMessages.append(message)
    }
    
    func reset() {
        infoMessages.removeAll()
        errorMessages.removeAll()
        debugMessages.removeAll()
    }
}

// Mock ë„¤íŠ¸ì›Œí¬ í´ë¼ì´ì–¸íŠ¸
final class MockNetworkClient: NetworkClient {
    var shouldFail = false
    var failureError: Error = NetworkError.serverError(500)
    var getResponses: [String: Any] = [:]
    var postResponses: [String: Any] = [:]
    
    private(set) var getRequests: [String] = []
    private(set) var postRequests: [(endpoint: String, body: Any)] = []
    
    func get<T: Codable>(_ endpoint: String) async throws -> T {
        getRequests.append(endpoint)
        
        if shouldFail {
            throw failureError
        }
        
        guard let response = getResponses[endpoint] as? T else {
            throw NetworkError.invalidResponse
        }
        
        return response
    }
    
    func post<T: Codable, U: Codable>(_ endpoint: String, body: T) async throws -> U {
        postRequests.append((endpoint, body))
        
        if shouldFail {
            throw failureError
        }
        
        guard let response = postResponses[endpoint] as? U else {
            throw NetworkError.invalidResponse
        }
        
        return response
    }
    
    func reset() {
        shouldFail = false
        getResponses.removeAll()
        postResponses.removeAll()
        getRequests.removeAll()
        postRequests.removeAll()
    }
}

// Mock ìºì‹œ ë§¤ë‹ˆì €
final class MockCacheManager: ResponseCacheManager {
    private var storage: [String: Any] = [:]
    private(set) var getRequests: [String] = []
    private(set) var setRequests: [(key: String, value: Any)] = []
    
    override func get<T: Codable>(_ key: String, type: T.Type) async -> T? {
        getRequests.append(key)
        return storage[key] as? T
    }
    
    override func set<T: Codable>(_ key: String, value: T) async {
        setRequests.append((key, value))
        storage[key] = value
    }
    
    override func clear() async {
        storage.removeAll()
    }
    
    func reset() {
        storage.removeAll()
        getRequests.removeAll()
        setRequests.removeAll()
    }
}
```

**6.2 í…ŒìŠ¤íŠ¸ í—¬í¼ ë° ë² ì´ìŠ¤ í´ë˜ìŠ¤**
```swift
// Tests/TutorialTests/TestHelpers/TestHelpers.swift
import XCTest
@testable import Tutorial
import Weaver

class WeaverTestCase: XCTestCase {
    var testContainer: WeaverContainer!
    var mockLogger: MockLogger!
    var mockNetworkClient: MockNetworkClient!
    var mockCacheManager: MockCacheManager!
    
    override func setUp() async throws {
        try await super.setUp()
        
        // Mock ê°ì²´ë“¤ ìƒì„±
        mockLogger = MockLogger()
        mockNetworkClient = MockNetworkClient()
        mockCacheManager = MockCacheManager()
        
        // í…ŒìŠ¤íŠ¸ìš© ì»¨í…Œì´ë„ˆ ìƒì„±
        testContainer = await WeaverContainer.builder()
            .override(LoggerKey.self) { _ in self.mockLogger }
            .override(NetworkClientKey.self) { _ in self.mockNetworkClient }
            .override(ResponseCacheManagerKey.self) { _ in self.mockCacheManager }
            .override(ErrorHandlingServiceKey.self) { _ in DefaultErrorHandlingService() }
            .build()
        
        // ì „ì—­ ìƒíƒœ ì´ˆê¸°í™”
        await Weaver.resetForTesting()
    }
    
    override func tearDown() async throws {
        // Mock ê°ì²´ë“¤ ì •ë¦¬
        mockLogger?.reset()
        mockNetworkClient?.reset()
        mockCacheManager?.reset()
        
        testContainer = nil
        mockLogger = nil
        mockNetworkClient = nil
        mockCacheManager = nil
        
        await Weaver.resetForTesting()
        try await super.tearDown()
    }
    
    /// í…ŒìŠ¤íŠ¸ ì»¨í…Œì´ë„ˆ ìŠ¤ì½”í”„ì—ì„œ ì‘ì—… ì‹¤í–‰
    func withTestScope<T>(_ operation: @escaping () async throws -> T) async throws -> T {
        return try await Weaver.withScope(testContainer) {
            try await operation()
        }
    }
}

// í…ŒìŠ¤íŠ¸ ë°ì´í„° íŒ©í† ë¦¬
struct TestDataFactory {
    static let sampleUser = User(
        id: "test-user-1",
        name: "í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì",
        email: "test@example.com",
        avatarURL: "https://example.com/avatar.jpg"
    )
    
    static let updatedUser = User(
        id: "test-user-1",
        name: "ì—…ë°ì´íŠ¸ëœ ì‚¬ìš©ì",
        email: "updated@example.com",
        avatarURL: "https://example.com/avatar.jpg"
    )
    
    static func createUsers(count: Int) -> [User] {
        return (1...count).map { index in
            User(
                id: "test-user-\(index)",
                name: "í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì \(index)",
                email: "test\(index)@example.com",
                avatarURL: nil
            )
        }
    }
}
```

**6.3 ì‚¬ìš©ì ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸**
```swift
// Tests/TutorialTests/Services/UserServiceTests.swift
import XCTest
@testable import Tutorial
import Weaver

final class UserServiceTests: WeaverTestCase {
    
    func testGetCurrentUser_Success() async throws {
        // Given
        let expectedUser = TestDataFactory.sampleUser
        mockNetworkClient.getResponses["/users/1"] = expectedUser
        
        // When
        let result = try await withTestScope {
            let service = ResilientUserService()
            return try await service.getCurrentUser()
        }
        
        // Then
        XCTAssertEqual(result?.id, expectedUser.id)
        XCTAssertEqual(result?.name, expectedUser.name)
        XCTAssertEqual(result?.email, expectedUser.email)
        
        // ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì´ ì˜¬ë°”ë¥´ê²Œ í˜¸ì¶œë˜ì—ˆëŠ”ì§€ í™•ì¸
        XCTAssertEqual(mockNetworkClient.getRequests.count, 1)
        XCTAssertEqual(mockNetworkClient.getRequests.first, "/users/1")
        
        // ë¡œê·¸ê°€ ì˜¬ë°”ë¥´ê²Œ ê¸°ë¡ë˜ì—ˆëŠ”ì§€ í™•ì¸
        XCTAssertTrue(mockLogger.infoMessages.contains { $0.contains("ì‚¬ìš©ì ì •ë³´ ìš”ì²­ ì‹œì‘") })
        XCTAssertTrue(mockLogger.infoMessages.contains { $0.contains("ì‚¬ìš©ì ì •ë³´ ìš”ì²­ ì„±ê³µ") })
    }
    
    func testGetCurrentUser_NetworkError_WithRetry() async throws {
        // Given
        mockNetworkClient.shouldFail = true
        mockNetworkClient.failureError = NetworkError.serverError(500)
        
        // When & Then
        await withTestScope {
            let service = ResilientUserService()
            
            do {
                _ = try await service.getCurrentUser()
                XCTFail("ì—ëŸ¬ê°€ ë°œìƒí•´ì•¼ í•©ë‹ˆë‹¤")
            } catch {
                // ì—ëŸ¬ê°€ AppErrorë¡œ ë˜í•‘ë˜ì—ˆëŠ”ì§€ í™•ì¸
                XCTAssertTrue(error is AppError)
                
                if case .network(let networkError) = error as? AppError {
                    XCTAssertTrue(networkError is NetworkError)
                } else {
                    XCTFail("NetworkErrorë¡œ ë˜í•‘ë˜ì–´ì•¼ í•©ë‹ˆë‹¤")
                }
            }
        }
        
        // ì¬ì‹œë„ê°€ 3ë²ˆ ìˆ˜í–‰ë˜ì—ˆëŠ”ì§€ í™•ì¸
        XCTAssertEqual(mockNetworkClient.getRequests.count, 3)
        
        // ì—ëŸ¬ ë¡œê·¸ê°€ ê¸°ë¡ë˜ì—ˆëŠ”ì§€ í™•ì¸
        XCTAssertTrue(mockLogger.errorMessages.contains { $0.contains("ìµœì¢… ì‹¤íŒ¨") })
    }
    
    func testGetCurrentUser_CacheHit() async throws {
        // Given
        let expectedUser = TestDataFactory.sampleUser
        let cacheKey = "cached_/users/1"
        
        // ìºì‹œì— ë°ì´í„° ë¯¸ë¦¬ ì €ì¥
        await mockCacheManager.set(cacheKey, value: expectedUser)
        
        // When
        let result = try await withTestScope {
            let service = ResilientUserService()
            return try await service.getCurrentUser()
        }
        
        // Then
        XCTAssertEqual(result?.id, expectedUser.id)
        
        // ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì´ í˜¸ì¶œë˜ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸ (ìºì‹œ íˆíŠ¸)
        XCTAssertEqual(mockNetworkClient.getRequests.count, 0)
        
        // ìºì‹œ ì¡°íšŒê°€ ìˆ˜í–‰ë˜ì—ˆëŠ”ì§€ í™•ì¸
        XCTAssertTrue(mockCacheManager.getRequests.contains(cacheKey))
    }
    
    func testUpdateProfile_Success() async throws {
        // Given
        let updatedUser = TestDataFactory.updatedUser
        mockNetworkClient.postResponses["/users/1"] = updatedUser
        
        // When
        try await withTestScope {
            let service = ResilientUserService()
            try await service.updateProfile(name: "ì—…ë°ì´íŠ¸ëœ ì‚¬ìš©ì", email: "updated@example.com")
        }
        
        // Then
        XCTAssertEqual(mockNetworkClient.postRequests.count, 1)
        
        let postRequest = mockNetworkClient.postRequests.first
        XCTAssertEqual(postRequest?.endpoint, "/users/1")
        
        // POST ìš”ì²­ ë°”ë”” í™•ì¸
        if let requestBody = postRequest?.body as? [String: String] {
            XCTAssertEqual(requestBody["name"], "ì—…ë°ì´íŠ¸ëœ ì‚¬ìš©ì")
            XCTAssertEqual(requestBody["email"], "updated@example.com")
        }
        
        // ì„±ê³µ ë¡œê·¸ í™•ì¸
        XCTAssertTrue(mockLogger.infoMessages.contains { $0.contains("í”„ë¡œí•„ ì—…ë°ì´íŠ¸ ì„±ê³µ") })
    }
    
    func testUpdateProfile_InvalidInput() async throws {
        // Given & When & Then
        await withTestScope {
            let service = ResilientUserService()
            
            // ë¹ˆ ì´ë¦„ìœ¼ë¡œ í…ŒìŠ¤íŠ¸
            do {
                try await service.updateProfile(name: "", email: "test@example.com")
                XCTFail("ì—ëŸ¬ê°€ ë°œìƒí•´ì•¼ í•©ë‹ˆë‹¤")
            } catch {
                XCTAssertTrue(error is UserError)
                if case .invalidInput = error as? UserError {
                    // ì˜¬ë°”ë¥¸ ì—ëŸ¬ íƒ€ì…
                } else {
                    XCTFail("UserError.invalidInputì´ì–´ì•¼ í•©ë‹ˆë‹¤")
                }
            }
            
            // ì˜ëª»ëœ ì´ë©”ì¼ë¡œ í…ŒìŠ¤íŠ¸
            do {
                try await service.updateProfile(name: "í…ŒìŠ¤íŠ¸", email: "invalid-email")
                XCTFail("ì—ëŸ¬ê°€ ë°œìƒí•´ì•¼ í•©ë‹ˆë‹¤")
            } catch {
                XCTAssertTrue(error is UserError)
            }
        }
        
        // ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì´ í˜¸ì¶œë˜ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸
        XCTAssertEqual(mockNetworkClient.postRequests.count, 0)
    }
}
```

**6.4 ìºì‹œëœ ë„¤íŠ¸ì›Œí¬ ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸**
```swift
// Tests/TutorialTests/Services/CachedNetworkServiceTests.swift
import XCTest
@testable import Tutorial
import Weaver

final class CachedNetworkServiceTests: WeaverTestCase {
    
    func testGetCachedData_CacheMiss() async throws {
        // Given
        let expectedUser = TestDataFactory.sampleUser
        mockNetworkClient.getResponses["/users/1"] = expectedUser
        
        // When
        let result: User = try await withTestScope {
            let service = CachedNetworkService()
            return try await service.getCachedData("/users/1", type: User.self)
        }
        
        // Then
        XCTAssertEqual(result.id, expectedUser.id)
        
        // ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì´ í˜¸ì¶œë˜ì—ˆëŠ”ì§€ í™•ì¸
        XCTAssertEqual(mockNetworkClient.getRequests.count, 1)
        
        // ìºì‹œì— ì €ì¥ë˜ì—ˆëŠ”ì§€ í™•ì¸
        XCTAssertEqual(mockCacheManager.setRequests.count, 1)
        XCTAssertEqual(mockCacheManager.setRequests.first?.key, "cached_/users/1")
    }
    
    func testGetCachedData_CacheHit() async throws {
        // Given
        let cachedUser = TestDataFactory.sampleUser
        let cacheKey = "cached_/users/1"
        await mockCacheManager.set(cacheKey, value: cachedUser)
        
        // When
        let result: User = try await withTestScope {
            let service = CachedNetworkService()
            return try await service.getCachedData("/users/1", type: User.self)
        }
        
        // Then
        XCTAssertEqual(result.id, cachedUser.id)
        
        // ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì´ í˜¸ì¶œë˜ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸
        XCTAssertEqual(mockNetworkClient.getRequests.count, 0)
        
        // ìºì‹œ ì¡°íšŒê°€ ìˆ˜í–‰ë˜ì—ˆëŠ”ì§€ í™•ì¸
        XCTAssertTrue(mockCacheManager.getRequests.contains(cacheKey))
    }
    
    func testGetCachedData_ForceRefresh() async throws {
        // Given
        let cachedUser = TestDataFactory.sampleUser
        let freshUser = TestDataFactory.updatedUser
        let cacheKey = "cached_/users/1"
        
        await mockCacheManager.set(cacheKey, value: cachedUser)
        mockNetworkClient.getResponses["/users/1"] = freshUser
        
        // When
        let result: User = try await withTestScope {
            let service = CachedNetworkService()
            return try await service.getCachedData("/users/1", type: User.self, forceRefresh: true)
        }
        
        // Then
        XCTAssertEqual(result.id, freshUser.id)
        XCTAssertEqual(result.name, freshUser.name)
        
        // ê°•ì œ ìƒˆë¡œê³ ì¹¨ì´ë¯€ë¡œ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì´ í˜¸ì¶œë˜ì–´ì•¼ í•¨
        XCTAssertEqual(mockNetworkClient.getRequests.count, 1)
        
        // ìƒˆë¡œìš´ ë°ì´í„°ê°€ ìºì‹œì— ì €ì¥ë˜ì—ˆëŠ”ì§€ í™•ì¸
        XCTAssertEqual(mockCacheManager.setRequests.count, 1)
    }
    
    func testPostWithCache_InvalidatesCacheKeys() async throws {
        // Given
        let request = ["name": "í…ŒìŠ¤íŠ¸", "email": "test@example.com"]
        let response = TestDataFactory.updatedUser
        mockNetworkClient.postResponses["/users/1"] = response
        
        // When
        let result: User = try await withTestScope {
            let service = CachedNetworkService()
            return try await service.postWithCache(
                "/users/1",
                body: request,
                responseType: User.self,
                invalidateCacheKeys: ["cached_/users/1", "cached_/users/list"]
            )
        }
        
        // Then
        XCTAssertEqual(result.id, response.id)
        
        // POST ìš”ì²­ì´ í˜¸ì¶œë˜ì—ˆëŠ”ì§€ í™•ì¸
        XCTAssertEqual(mockNetworkClient.postRequests.count, 1)
        
        // ìºì‹œ ë¬´íš¨í™” ë¡œê·¸ê°€ ê¸°ë¡ë˜ì—ˆëŠ”ì§€ í™•ì¸
        XCTAssertTrue(mockLogger.infoMessages.contains { $0.contains("ìºì‹œ ë¬´íš¨í™”") })
    }
}
```

**6.5 ì—ëŸ¬ ì²˜ë¦¬ ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸**
```swift
// Tests/TutorialTests/Services/ErrorHandlingServiceTests.swift
import XCTest
@testable import Tutorial
import Weaver

final class ErrorHandlingServiceTests: WeaverTestCase {
    
    func testHandleError_NetworkError() async throws {
        // Given
        let networkError = NetworkError.serverError(500)
        
        // When
        let result = await withTestScope {
            let service = DefaultErrorHandlingService()
            return await service.handleError(networkError)
        }
        
        // Then
        if case .network(let wrappedError) = result {
            XCTAssertTrue(wrappedError is NetworkError)
        } else {
            XCTFail("NetworkErrorë¡œ ë˜í•‘ë˜ì–´ì•¼ í•©ë‹ˆë‹¤")
        }
        
        // ì—ëŸ¬ ë¡œê·¸ê°€ ê¸°ë¡ë˜ì—ˆëŠ”ì§€ í™•ì¸
        XCTAssertTrue(mockLogger.errorMessages.contains { $0.contains("ì—ëŸ¬ ì²˜ë¦¬") })
    }
    
    func testShouldRetry_RetryableErrors() async throws {
        // Given
        let service = DefaultErrorHandlingService()
        
        // When & Then
        await withTestScope {
            // ì„œë²„ ì—ëŸ¬ëŠ” ì¬ì‹œë„ ê°€ëŠ¥
            let serverError = AppError.network(.serverError(500))
            XCTAssertTrue(service.shouldRetry(serverError))
            
            // í´ë¼ì´ì–¸íŠ¸ ì—ëŸ¬ëŠ” ì¬ì‹œë„ ë¶ˆê°€ëŠ¥
            let clientError = AppError.network(.clientError(400))
            XCTAssertFalse(service.shouldRetry(clientError))
            
            // ì‚¬ìš©ì ì—ëŸ¬ëŠ” ì¬ì‹œë„ ë¶ˆê°€ëŠ¥
            let userError = AppError.user(.invalidInput)
            XCTAssertFalse(service.shouldRetry(userError))
        }
    }
    
    func testGetRetryDelay_ExponentialBackoff() async throws {
        // Given
        let service = DefaultErrorHandlingService()
        let error = AppError.network(.serverError(500))
        
        // When & Then
        await withTestScope {
            // ì§€ìˆ˜ ë°±ì˜¤í”„ í™•ì¸
            XCTAssertEqual(service.getRetryDelay(error, attempt: 1), 2.0)  // 2^1
            XCTAssertEqual(service.getRetryDelay(error, attempt: 2), 4.0)  // 2^2
            XCTAssertEqual(service.getRetryDelay(error, attempt: 3), 8.0)  // 2^3
            XCTAssertEqual(service.getRetryDelay(error, attempt: 4), 16.0) // 2^4
            
            // ìµœëŒ€ 30ì´ˆ ì œí•œ í™•ì¸
            XCTAssertEqual(service.getRetryDelay(error, attempt: 10), 30.0)
        }
    }
}
```

**6.6 í†µí•© í…ŒìŠ¤íŠ¸**
```swift
// Tests/TutorialTests/Integration/UserProfileIntegrationTests.swift
import XCTest
@testable import Tutorial
import Weaver

final class UserProfileIntegrationTests: WeaverTestCase {
    
    func testUserProfileFlow_SuccessPath() async throws {
        // Given
        let initialUser = TestDataFactory.sampleUser
        let updatedUser = TestDataFactory.updatedUser
        
        mockNetworkClient.getResponses["/users/1"] = initialUser
        mockNetworkClient.postResponses["/users/1"] = updatedUser
        
        // When & Then - ì‚¬ìš©ì ì •ë³´ ë¡œë”©
        let loadedUser = try await withTestScope {
            let service = ResilientUserService()
            return try await service.getCurrentUser()
        }
        
        XCTAssertEqual(loadedUser?.id, initialUser.id)
        XCTAssertEqual(loadedUser?.name, initialUser.name)
        
        // When & Then - í”„ë¡œí•„ ì—…ë°ì´íŠ¸
        try await withTestScope {
            let service = ResilientUserService()
            try await service.updateProfile(name: updatedUser.name, email: updatedUser.email)
        }
        
        // ì „ì²´ í”Œë¡œìš° ê²€ì¦
        XCTAssertEqual(mockNetworkClient.getRequests.count, 1)
        XCTAssertEqual(mockNetworkClient.postRequests.count, 1)
        
        // ìºì‹œ ë™ì‘ ê²€ì¦
        XCTAssertEqual(mockCacheManager.setRequests.count, 1) // GET ì‘ë‹µ ìºì‹œ
        
        // ë¡œê·¸ ê²€ì¦
        XCTAssertTrue(mockLogger.infoMessages.contains { $0.contains("ì‚¬ìš©ì ì •ë³´ ìš”ì²­ ì„±ê³µ") })
        XCTAssertTrue(mockLogger.infoMessages.contains { $0.contains("í”„ë¡œí•„ ì—…ë°ì´íŠ¸ ì„±ê³µ") })
    }
    
    func testUserProfileFlow_NetworkFailureRecovery() async throws {
        // Given
        let user = TestDataFactory.sampleUser
        
        // ì²˜ìŒ 2ë²ˆì€ ì‹¤íŒ¨, 3ë²ˆì§¸ëŠ” ì„±ê³µ
        var callCount = 0
        mockNetworkClient.shouldFail = true
        mockNetworkClient.failureError = NetworkError.serverError(500)
        
        // 3ë²ˆì§¸ í˜¸ì¶œì—ì„œ ì„±ê³µí•˜ë„ë¡ ì„¤ì •
        let originalGet = mockNetworkClient.get
        mockNetworkClient.get = { endpoint in
            callCount += 1
            if callCount >= 3 {
                self.mockNetworkClient.shouldFail = false
                self.mockNetworkClient.getResponses[endpoint] = user
            }
            return try await originalGet(endpoint)
        }
        
        // When
        let result = try await withTestScope {
            let service = ResilientUserService()
            return try await service.getCurrentUser()
        }
        
        // Then
        XCTAssertEqual(result?.id, user.id)
        XCTAssertEqual(mockNetworkClient.getRequests.count, 3) // 3ë²ˆ ì‹œë„
        
        // ì¬ì‹œë„ ë¡œê·¸ í™•ì¸
        XCTAssertTrue(mockLogger.infoMessages.contains { $0.contains("ì¬ì‹œë„ ëŒ€ê¸°") })
        XCTAssertTrue(mockLogger.infoMessages.contains { $0.contains("ì‚¬ìš©ì ì •ë³´ ìš”ì²­ ì„±ê³µ") })
    }
}
```

**6.7 ì„±ëŠ¥ í…ŒìŠ¤íŠ¸**
```swift
// Tests/TutorialTests/Performance/PerformanceTests.swift
import XCTest
@testable import Tutorial
import Weaver

final class PerformanceTests: WeaverTestCase {
    
    func testUserServicePerformance() async throws {
        // Given
        let user = TestDataFactory.sampleUser
        mockNetworkClient.getResponses["/users/1"] = user
        
        // When & Then
        measure {
            let expectation = XCTestExpectation(description: "User service performance")
            
            Task {
                try await self.withTestScope {
                    let service = ResilientUserService()
                    _ = try await service.getCurrentUser()
                }
                expectation.fulfill()
            }
            
            wait(for: [expectation], timeout: 1.0)
        }
    }
    
    func testCachePerformance() async throws {
        // Given
        let users = TestDataFactory.createUsers(count: 100)
        
        // ìºì‹œì— 100ê°œ ì‚¬ìš©ì ì €ì¥
        for (index, user) in users.enumerated() {
            await mockCacheManager.set("user_\(index)", value: user)
        }
        
        // When & Then - ìºì‹œ ì¡°íšŒ ì„±ëŠ¥ ì¸¡ì •
        measure {
            let expectation = XCTestExpectation(description: "Cache performance")
            
            Task {
                for index in 0..<100 {
                    _ = await self.mockCacheManager.get("user_\(index)", type: User.self)
                }
                expectation.fulfill()
            }
            
            wait(for: [expectation], timeout: 1.0)
        }
    }
}
```

#### ğŸ’¡ í•µì‹¬ í¬ì¸íŠ¸
- Mock ê°ì²´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì™¸ë¶€ ì˜ì¡´ì„±ì„ ì œê±°í•©ë‹ˆë‹¤
- `WeaverTestCase` ë² ì´ìŠ¤ í´ë˜ìŠ¤ë¡œ í…ŒìŠ¤íŠ¸ ì„¤ì •ì„ í‘œì¤€í™”í•©ë‹ˆë‹¤
- ë‹¨ìœ„ í…ŒìŠ¤íŠ¸, í†µí•© í…ŒìŠ¤íŠ¸, ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ë¥¼ ëª¨ë‘ ì‘ì„±í•©ë‹ˆë‹¤
- í…ŒìŠ¤íŠ¸ì—ì„œë„ DI ì»¨í…Œì´ë„ˆë¥¼ ì‚¬ìš©í•˜ì—¬ ì¼ê´€ì„±ì„ ìœ ì§€í•©ë‹ˆë‹¤

**ğŸ‰ ì¤‘ê¸‰ ë ˆë²¨ ì™„ë£Œ!** ì´ì œ ì‹¤ì œ í”„ë¡œë•ì…˜ ì•±ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ìˆ˜ì¤€ì˜ Weaver DI ì‹œìŠ¤í…œì„ êµ¬ì¶•í–ˆìŠµë‹ˆë‹¤.

---

## ğŸ”´ ê³ ê¸‰ ë ˆë²¨

ê³ ê¸‰ ë ˆë²¨ì—ì„œëŠ” ì‹¤ì œ í”„ë¡œë•ì…˜ ì•±ì—ì„œ í•„ìš”í•œ ë³µì¡í•œ íŒ¨í„´ë“¤ì„ ë‹¤ë£¹ë‹ˆë‹¤. ì¸ì¦ ì‹œìŠ¤í…œ, ì„±ëŠ¥ ìµœì í™”, A/B í…ŒìŠ¤íŠ¸ ë“± ê³ ê¸‰ ì£¼ì œë“¤ì„ í•™ìŠµí•©ë‹ˆë‹¤.

### 7ë‹¨ê³„: ì¸ì¦ ì‹œìŠ¤í…œ êµ¬í˜„

#### ğŸ¯ í•™ìŠµ ëª©í‘œ
- JWT í† í° ê¸°ë°˜ ì¸ì¦ ì‹œìŠ¤í…œ
- ìë™ í† í° ê°±ì‹  ë©”ì»¤ë‹ˆì¦˜
- í‚¤ì²´ì¸ì„ í™œìš©í•œ ë³´ì•ˆ ì €ì¥ì†Œ

#### ğŸ“ ì‹¤ìŠµ: ì™„ì „í•œ ì¸ì¦ ì‹œìŠ¤í…œ

**7.1 ì¸ì¦ í† í° ëª¨ë¸**
```swift
// Models/AuthToken.swift
import Foundation

struct AuthToken: Codable, Sendable {
    let accessToken: String
    let refreshToken: String
    let tokenType: String
    let expiresIn: Int
    let scope: String?
    
    private let issuedAt: Date
    
    init(accessToken: String, refreshToken: String, tokenType: String = "Bearer", expiresIn: Int, scope: String? = nil) {
        self.accessToken = accessToken
        self.refreshToken = refreshToken
        self.tokenType = tokenType
        self.expiresIn = expiresIn
        self.scope = scope
        self.issuedAt = Date()
    }
    
    var expiresAt: Date {
        issuedAt.addingTimeInterval(TimeInterval(expiresIn))
    }
    
    var isExpired: Bool {
        Date() >= expiresAt
    }
    
    var willExpireSoon: Bool {
        // ë§Œë£Œ 5ë¶„ ì „ì„ "ê³§ ë§Œë£Œ"ë¡œ ê°„ì£¼
        Date().addingTimeInterval(300) >= expiresAt
    }
    
    var authorizationHeader: String {
        "\(tokenType) \(accessToken)"
    }
}

// ë¡œê·¸ì¸ ìš”ì²­/ì‘ë‹µ ëª¨ë¸
struct LoginRequest: Codable {
    let email: String
    let password: String
    let deviceId: String
    let deviceName: String
}

struct LoginResponse: Codable {
    let accessToken: String
    let refreshToken: String
    let tokenType: String
    let expiresIn: Int
    let user: User
}

struct RefreshTokenRequest: Codable {
    let refreshToken: String
}

struct RefreshTokenResponse: Codable {
    let accessToken: String
    let refreshToken: String
    let tokenType: String
    let expiresIn: Int
}
```
