# Weaver DI ÏôÑÏ†Ñ ÌäúÌÜ†Î¶¨Ïñº

> üéØ **Ïã§Ïäµ Ï§ëÏã¨ ÌïôÏäµ** | **Îã®Í≥ÑÎ≥Ñ Í∞ÄÏù¥Îìú** | **Ïã§Ï†ú Ïï± Í∞úÎ∞ú ÏãúÎÇòÎ¶¨Ïò§**

Ïù¥ ÌäúÌÜ†Î¶¨ÏñºÏùÄ Weaver DIÎ•º Ï≤òÏùå ÏÇ¨Ïö©ÌïòÎäî Í∞úÎ∞úÏûêÎ∂ÄÌÑ∞ Í≥†Í∏â Ìå®ÌÑ¥ÏùÑ Î∞∞Ïö∞Í≥† Ïã∂ÏùÄ Í∞úÎ∞úÏûêÍπåÏßÄ Î™®Îì† Î†àÎ≤®ÏùÑ ÏúÑÌïú ÏôÑÏ†ÑÌïú ÌïôÏäµ Í∞ÄÏù¥ÎìúÏûÖÎãàÎã§.

## üìã ÌïôÏäµ Î™©Ìëú

Ïù¥ ÌäúÌÜ†Î¶¨ÏñºÏùÑ ÏôÑÎ£åÌïòÎ©¥ Îã§ÏùåÏùÑ Ìï† Ïàò ÏûàÏäµÎãàÎã§:
- ‚úÖ Weaver DIÏùò ÌïµÏã¨ Í∞úÎÖê Ïù¥Ìï¥
- ‚úÖ Ïã§Ï†ú Ïï±ÏóêÏÑú ÏùòÏ°¥ÏÑ± Ï£ºÏûÖ Íµ¨ÌòÑ
- ‚úÖ SwiftUIÏôÄ UIKitÏóêÏÑú ÏïàÏ†ÑÌïòÍ≤å ÏÇ¨Ïö©
- ‚úÖ ÌÖåÏä§Ìä∏ Í∞ÄÎä•Ìïú ÏΩîÎìú ÏûëÏÑ±
- ‚úÖ ÏÑ±Îä• ÏµúÏ†ÅÌôî Î∞è Î©îÎ™®Î¶¨ Í¥ÄÎ¶¨
- ‚úÖ Í≥†Í∏â Ìå®ÌÑ¥ Ï†ÅÏö© (A/B ÌÖåÏä§Ìä∏, Ïù∏Ï¶ù Îì±)

## üéì Î†àÎ≤®Î≥Ñ ÌïôÏäµ Í≤ΩÎ°ú

### üü¢ Ï¥àÍ∏â (Beginner)
- [1Îã®Í≥Ñ: Í∏∞Î≥∏ Í∞úÎÖêÍ≥º Ï≤´ Î≤àÏß∏ ÏùòÏ°¥ÏÑ±](#1Îã®Í≥Ñ-Í∏∞Î≥∏-Í∞úÎÖêÍ≥º-Ï≤´-Î≤àÏß∏-ÏùòÏ°¥ÏÑ±)
- [2Îã®Í≥Ñ: SwiftUIÏóêÏÑú ÏÇ¨Ïö©ÌïòÍ∏∞](#2Îã®Í≥Ñ-swiftuiÏóêÏÑú-ÏÇ¨Ïö©ÌïòÍ∏∞)
- [3Îã®Í≥Ñ: Î™®ÎìàÎ°ú ÏùòÏ°¥ÏÑ± Í∑∏Î£πÌôî](#3Îã®Í≥Ñ-Î™®ÎìàÎ°ú-ÏùòÏ°¥ÏÑ±-Í∑∏Î£πÌôî)

### üü° Ï§ëÍ∏â (Intermediate)  
- [4Îã®Í≥Ñ: ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÑúÎπÑÏä§ Íµ¨ÌòÑ](#4Îã®Í≥Ñ-ÎÑ§Ìä∏ÏõåÌÅ¨-ÏÑúÎπÑÏä§-Íµ¨ÌòÑ)
- [5Îã®Í≥Ñ: ÏóêÎü¨ Ï≤òÎ¶¨ÏôÄ ÏïàÏ†ÑÏÑ±](#5Îã®Í≥Ñ-ÏóêÎü¨-Ï≤òÎ¶¨ÏôÄ-ÏïàÏ†ÑÏÑ±)
- [6Îã®Í≥Ñ: ÌÖåÏä§Ìä∏ ÏûëÏÑ±ÌïòÍ∏∞](#6Îã®Í≥Ñ-ÌÖåÏä§Ìä∏-ÏûëÏÑ±ÌïòÍ∏∞)

### üî¥ Í≥†Í∏â (Advanced)
- [7Îã®Í≥Ñ: Ïù∏Ï¶ù ÏãúÏä§ÌÖú Íµ¨ÌòÑ](#7Îã®Í≥Ñ-Ïù∏Ï¶ù-ÏãúÏä§ÌÖú-Íµ¨ÌòÑ)
- [8Îã®Í≥Ñ: ÏÑ±Îä• ÏµúÏ†ÅÌôî](#8Îã®Í≥Ñ-ÏÑ±Îä•-ÏµúÏ†ÅÌôî)
- [9Îã®Í≥Ñ: A/B ÌÖåÏä§Ìä∏ ÏãúÏä§ÌÖú](#9Îã®Í≥Ñ-ab-ÌÖåÏä§Ìä∏-ÏãúÏä§ÌÖú)

---

## üü¢ Ï¥àÍ∏â Î†àÎ≤®

### 1Îã®Í≥Ñ: Í∏∞Î≥∏ Í∞úÎÖêÍ≥º Ï≤´ Î≤àÏß∏ ÏùòÏ°¥ÏÑ±

#### üéØ ÌïôÏäµ Î™©Ìëú
- DependencyKey ÌîÑÎ°úÌÜ†ÏΩú Ïù¥Ìï¥
- Ï≤´ Î≤àÏß∏ ÏÑúÎπÑÏä§ ÎßåÎì§Í∏∞
- @Inject ÌîÑÎ°úÌçºÌã∞ ÎûòÌçº ÏÇ¨Ïö©Î≤ï

#### üìù Ïã§Ïäµ: Í∞ÑÎã®Ìïú Î°úÍ±∞ ÏÑúÎπÑÏä§

**1.1 ÏÑúÎπÑÏä§ ÌîÑÎ°úÌÜ†ÏΩú Ï†ïÏùò**
```swift
import Weaver

// Î°úÍπÖ Í∏∞Îä•ÏùÑ Ï†ïÏùòÌïòÎäî ÌîÑÎ°úÌÜ†ÏΩú
protocol Logger: Sendable {
    func info(_ message: String)
    func error(_ message: String)
    func debug(_ message: String)
}
```

**1.2 Ïã§Ï†ú Íµ¨ÌòÑÏ≤¥ ÎßåÎì§Í∏∞**
```swift
// ÏΩòÏÜîÏóê Î°úÍ∑∏Î•º Ï∂úÎ†•ÌïòÎäî Íµ¨ÌòÑÏ≤¥
final class ConsoleLogger: Logger {
    private let dateFormatter: DateFormatter
    
    init() {
        dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "HH:mm:ss.SSS"
    }
    
    func info(_ message: String) {
        let timestamp = dateFormatter.string(from: Date())
        print("[\(timestamp)] [INFO] \(message)")
    }
    
    func error(_ message: String) {
        let timestamp = dateFormatter.string(from: Date())
        print("[\(timestamp)] [ERROR] \(message)")
    }
    
    func debug(_ message: String) {
        #if DEBUG
        let timestamp = dateFormatter.string(from: Date())
        print("[\(timestamp)] [DEBUG] \(message)")
        #endif
    }
}
```*
*1.3 ÏùòÏ°¥ÏÑ± ÌÇ§ Ï†ïÏùò**
```swift
// ÏùòÏ°¥ÏÑ± ÌÇ§ - ÌÉÄÏûÖ ÏïàÏ†ÑÏÑ±Ïùò ÌïµÏã¨!
struct LoggerKey: DependencyKey {
    typealias Value = Logger
    
    // üéØ ÌÅ¨ÎûòÏãú Î∞©ÏßÄÎ•º ÏúÑÌïú ÏïàÏ†ÑÌïú Í∏∞Î≥∏Í∞í
    static var defaultValue: Logger {
        if WeaverEnvironment.isPreview {
            return PreviewLogger() // PreviewÏö© Í∞ÑÎã®Ìïú Î°úÍ±∞
        } else {
            return ConsoleLogger()
        }
    }
}

// PreviewÏö© Í∞ÑÎã®Ìïú Î°úÍ±∞
struct PreviewLogger: Logger {
    func info(_ message: String) { print("Preview: \(message)") }
    func error(_ message: String) { print("Preview Error: \(message)") }
    func debug(_ message: String) { print("Preview Debug: \(message)") }
}
```

**1.4 Ïï±ÏóêÏÑú ÏÇ¨Ïö©ÌïòÍ∏∞**
```swift
// App.swift
@main
struct TutorialApp: App {
    init() {
        // Ïï± ÏãúÏûë Ïãú DI ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî
        Task {
            try await Weaver.setup(modules: [LoggingModule()])
        }
    }
    
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}

// Î°úÍπÖ Î™®Îìà
struct LoggingModule: Module {
    func configure(_ builder: WeaverBuilder) async {
        await builder.register(LoggerKey.self, scope: .shared) { _ in
            ConsoleLogger()
        }
    }
}

// ContentView.swift
struct ContentView: View {
    @Inject(LoggerKey.self) private var logger
    
    var body: some View {
        VStack(spacing: 20) {
            Text("Weaver DI ÌäúÌÜ†Î¶¨Ïñº")
                .font(.title)
            
            Button("Ï†ïÎ≥¥ Î°úÍ∑∏") {
                Task {
                    let log = await logger()
                    log.info("Ï†ïÎ≥¥ Î≤ÑÌäºÏù¥ ÌÅ¥Î¶≠ÎêòÏóàÏäµÎãàÎã§!")
                }
            }
            
            Button("ÏóêÎü¨ Î°úÍ∑∏") {
                Task {
                    let log = await logger()
                    log.error("ÏóêÎü¨ Î≤ÑÌäºÏù¥ ÌÅ¥Î¶≠ÎêòÏóàÏäµÎãàÎã§!")
                }
            }
            
            Button("ÎîîÎ≤ÑÍ∑∏ Î°úÍ∑∏") {
                Task {
                    let log = await logger()
                    log.debug("ÎîîÎ≤ÑÍ∑∏ Î≤ÑÌäºÏù¥ ÌÅ¥Î¶≠ÎêòÏóàÏäµÎãàÎã§!")
                }
            }
        }
        .padding()
    }
}
```

**üéâ Ï∂ïÌïòÌï©ÎãàÎã§!** Ï≤´ Î≤àÏß∏ ÏùòÏ°¥ÏÑ± Ï£ºÏûÖÏùÑ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Íµ¨ÌòÑÌñàÏäµÎãàÎã§.

#### üí° ÌïµÏã¨ Ìè¨Ïù∏Ìä∏
- `DependencyKey`Îäî ÌÉÄÏûÖ ÏïàÏ†ÑÏÑ±ÏùÑ Î≥¥Ïû•Ìï©ÎãàÎã§
- `defaultValue`Îäî Ï†àÎåÄ `fatalError()`Î•º ÏÇ¨Ïö©ÌïòÏßÄ ÎßàÏÑ∏Ïöî
- `@Inject`Ïùò `callAsFunction()`ÏùÄ Ï†àÎåÄ ÌÅ¨ÎûòÏãúÌïòÏßÄ ÏïäÏäµÎãàÎã§
- `scope: .shared`Îäî Ïã±Í∏ÄÌÜ§ Ìå®ÌÑ¥ÏûÖÎãàÎã§

---

### 2Îã®Í≥Ñ: SwiftUIÏóêÏÑú ÏÇ¨Ïö©ÌïòÍ∏∞

#### üéØ ÌïôÏäµ Î™©Ìëú
- SwiftUI ViewÏóêÏÑú ÏïàÏ†ÑÌïú ÏùòÏ°¥ÏÑ± ÏÇ¨Ïö©
- PreviewÏóêÏÑú Mock Í∞ùÏ≤¥ ÏÇ¨Ïö©
- View ÏÉùÎ™ÖÏ£ºÍ∏∞ÏôÄ DI ÎèôÍ∏∞Ìôî

#### üìù Ïã§Ïäµ: ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ ÌôîÎ©¥

**2.1 ÏÇ¨Ïö©Ïûê Î™®Îç∏ Ï†ïÏùò**
```swift
struct User: Codable, Identifiable, Sendable {
    let id: String
    let name: String
    let email: String
    let avatarURL: String?
    
    static let mock = User(
        id: "mock-user",
        name: "ÍπÄÏ≤†Ïàò",
        email: "kim@example.com",
        avatarURL: nil
    )
}
```

**2.2 ÏÇ¨Ïö©Ïûê ÏÑúÎπÑÏä§ Íµ¨ÌòÑ**
```swift
protocol UserService: Sendable {
    func getCurrentUser() async throws -> User?
    func updateProfile(name: String, email: String) async throws
}

// Ïã§Ï†ú Íµ¨ÌòÑÏ≤¥ (ÎÇòÏ§ëÏóê ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Îèô)
final class APIUserService: UserService {
    @Inject(LoggerKey.self) private var logger
    
    func getCurrentUser() async throws -> User? {
        let log = await logger()
        log.info("ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò§Îäî Ï§ë...")
        
        // ÏãúÎÆ¨Î†àÏù¥ÏÖòÏùÑ ÏúÑÌïú ÏßÄÏó∞
        try await Task.sleep(for: .seconds(1))
        
        log.info("ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Î°úÎî© ÏôÑÎ£å")
        return User.mock
    }
    
    func updateProfile(name: String, email: String) async throws {
        let log = await logger()
        log.info("ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏: \(name), \(email)")
        
        // ÏãúÎÆ¨Î†àÏù¥ÏÖòÏùÑ ÏúÑÌïú ÏßÄÏó∞
        try await Task.sleep(for: .milliseconds(500))
        
        log.info("ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å")
    }
}

// Mock Íµ¨ÌòÑÏ≤¥ (ÌÖåÏä§Ìä∏/PreviewÏö©)
final class MockUserService: UserService {
    func getCurrentUser() async throws -> User? {
        return User.mock
    }
    
    func updateProfile(name: String, email: String) async throws {
        print("Mock: ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ - \(name), \(email)")
    }
}

// ÏùòÏ°¥ÏÑ± ÌÇ§
struct UserServiceKey: DependencyKey {
    typealias Value = UserService
    static var defaultValue: UserService { MockUserService() }
}
```

**2.3 ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ View Íµ¨ÌòÑ**
```swift
struct UserProfileView: View {
    @Inject(UserServiceKey.self) private var userService
    @Inject(LoggerKey.self) private var logger
    
    @State private var user: User?
    @State private var isLoading = false
    @State private var errorMessage: String?
    @State private var isEditing = false
    @State private var editName = ""
    @State private var editEmail = ""
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                if isLoading {
                    ProgressView("ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Î°úÎî© Ï§ë...")
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else if let user = user {
                    userInfoView(user)
                } else {
                    Text("ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§")
                        .foregroundColor(.secondary)
                }
            }
            .navigationTitle("ÌîÑÎ°úÌïÑ")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                if user != nil && !isLoading {
                    Button(isEditing ? "ÏôÑÎ£å" : "Ìé∏Ïßë") {
                        if isEditing {
                            Task { await saveProfile() }
                        } else {
                            startEditing()
                        }
                    }
                }
            }
            .alert("Ïò§Î•ò", isPresented: .constant(errorMessage != nil)) {
                Button("ÌôïÏù∏") { errorMessage = nil }
            } message: {
                Text(errorMessage ?? "")
            }
        }
        .task {
            await loadUser()
        }
    }
    
    @ViewBuilder
    private func userInfoView(_ user: User) -> some View {
        VStack(spacing: 16) {
            // ÏïÑÎ∞îÌÉÄ
            AsyncImage(url: user.avatarURL.flatMap(URL.init)) { image in
                image
                    .resizable()
                    .aspectRatio(contentMode: .fill)
            } placeholder: {
                Image(systemName: "person.circle.fill")
                    .font(.system(size: 80))
                    .foregroundColor(.gray)
            }
            .frame(width: 100, height: 100)
            .clipShape(Circle())
            
            // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥
            if isEditing {
                VStack(spacing: 12) {
                    TextField("Ïù¥Î¶Ñ", text: $editName)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                    
                    TextField("Ïù¥Î©îÏùº", text: $editEmail)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .keyboardType(.emailAddress)
                        .autocapitalization(.none)
                }
                .padding(.horizontal)
            } else {
                VStack(spacing: 8) {
                    Text(user.name)
                        .font(.title2)
                        .fontWeight(.bold)
                    
                    Text(user.email)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
            }
            
            Spacer()
        }
        .padding()
    }
    
    private func loadUser() async {
        isLoading = true
        errorMessage = nil
        defer { isLoading = false }
        
        do {
            let service = await userService()
            user = try await service.getCurrentUser()
            
            let log = await logger()
            log.info("ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ Î°úÎî© ÏÑ±Í≥µ")
        } catch {
            errorMessage = error.localizedDescription
            
            let log = await logger()
            log.error("ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ Î°úÎî© Ïã§Ìå®: \(error)")
        }
    }
    
    private func startEditing() {
        guard let user = user else { return }
        editName = user.name
        editEmail = user.email
        isEditing = true
    }
    
    private func saveProfile() async {
        guard !editName.isEmpty, !editEmail.isEmpty else {
            errorMessage = "Ïù¥Î¶ÑÍ≥º Ïù¥Î©îÏùºÏùÑ Î™®Îëê ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî"
            return
        }
        
        isLoading = true
        defer { isLoading = false }
        
        do {
            let service = await userService()
            try await service.updateProfile(name: editName, email: editEmail)
            
            // ÏÑ±Í≥µ Ïãú Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
            user = User(id: user?.id ?? "", name: editName, email: editEmail, avatarURL: user?.avatarURL)
            isEditing = false
            
            let log = await logger()
            log.info("ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ ÏÑ±Í≥µ")
        } catch {
            errorMessage = error.localizedDescription
            
            let log = await logger()
            log.error("ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®: \(error)")
        }
    }
}
```

**2.4 Preview ÏÑ§Ï†ï**
```swift
#Preview("Í∏∞Î≥∏ ÏÉÅÌÉú") {
    UserProfileView()
        .weaver(modules: PreviewWeaverContainer.previewModules(
            .register(LoggerKey.self, mockValue: PreviewLogger()),
            .register(UserServiceKey.self, mockValue: MockUserService())
        ))
}

#Preview("Î°úÎî© ÏÉÅÌÉú") {
    UserProfileView()
        .weaver(modules: PreviewWeaverContainer.previewModules(
            .register(LoggerKey.self, mockValue: PreviewLogger()),
            .register(UserServiceKey.self) { _ in
                SlowMockUserService() // ÏùòÎèÑÏ†ÅÏúºÎ°ú ÎäêÎ¶∞ ÏÑúÎπÑÏä§
            }
        ))
}

// ÎäêÎ¶∞ Mock ÏÑúÎπÑÏä§ (Î°úÎî© ÏÉÅÌÉú ÌÖåÏä§Ìä∏Ïö©)
final class SlowMockUserService: UserService {
    func getCurrentUser() async throws -> User? {
        try await Task.sleep(for: .seconds(3)) // 3Ï¥à ÏßÄÏó∞
        return User.mock
    }
    
    func updateProfile(name: String, email: String) async throws {
        try await Task.sleep(for: .seconds(2)) // 2Ï¥à ÏßÄÏó∞
    }
}
```

**2.5 Î™®Îìà ÏóÖÎç∞Ïù¥Ìä∏**
```swift
struct UserModule: Module {
    func configure(_ builder: WeaverBuilder) async {
        await builder.register(UserServiceKey.self, scope: .shared) { _ in
            APIUserService()
        }
    }
}

// App.swift ÏóÖÎç∞Ïù¥Ìä∏
@main
struct TutorialApp: App {
    init() {
        Task {
            try await Weaver.setup(modules: [
                LoggingModule(),
                UserModule()
            ])
        }
    }
    
    var body: some Scene {
        WindowGroup {
            UserProfileView() // ContentView ÎåÄÏã† UserProfileView ÏÇ¨Ïö©
        }
    }
}
```

#### üí° ÌïµÏã¨ Ìè¨Ïù∏Ìä∏
- SwiftUIÏóêÏÑú `@Inject`Îäî `@State`ÏôÄ Ìï®Íªò ÏÇ¨Ïö©Îê©ÎãàÎã§
- `task` modifierÎ°ú View ÏÉùÎ™ÖÏ£ºÍ∏∞ÏôÄ ÎèôÍ∏∞ÌôîÌï©ÎãàÎã§
- PreviewÏóêÏÑúÎäî Mock Í∞ùÏ≤¥Î•º ÏÇ¨Ïö©ÌïòÏó¨ Îã§ÏñëÌïú ÏÉÅÌÉúÎ•º ÌÖåÏä§Ìä∏Ìï©ÎãàÎã§
- ÏóêÎü¨ Ï≤òÎ¶¨Îäî ÏÇ¨Ïö©Ïûê ÏπúÌôîÏ†ÅÏúºÎ°ú Íµ¨ÌòÑÌï©ÎãàÎã§

---

### 3Îã®Í≥Ñ: Î™®ÎìàÎ°ú ÏùòÏ°¥ÏÑ± Í∑∏Î£πÌôî

#### üéØ ÌïôÏäµ Î™©Ìëú
- Í¥ÄÎ†® ÏùòÏ°¥ÏÑ±Îì§ÏùÑ Î™®ÎìàÎ°ú Í∑∏Î£πÌôî
- Î™®Îìà Í∞Ñ ÏùòÏ°¥ÏÑ± Í¥ÄÎ¶¨
- Ïä§ÏΩîÌîÑÏùò Ïò¨Î∞îÎ•∏ ÏÇ¨Ïö©Î≤ï

#### üìù Ïã§Ïäµ: ÎÑ§Ìä∏ÏõåÌÅ¨ Î™®Îìà Ï∂îÍ∞Ä

**3.1 ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Íµ¨ÌòÑ**
```swift
protocol NetworkClient: Sendable {
    func get<T: Codable>(_ endpoint: String) async throws -> T
    func post<T: Codable, U: Codable>(_ endpoint: String, body: T) async throws -> U
}

final class URLSessionNetworkClient: NetworkClient {
    private let baseURL: String
    private let session: URLSession
    
    @Inject(LoggerKey.self) private var logger
    
    init(baseURL: String, session: URLSession = .shared) {
        self.baseURL = baseURL
        self.session = session
    }
    
    func get<T: Codable>(_ endpoint: String) async throws -> T {
        let log = await logger()
        log.info("GET ÏöîÏ≤≠: \(endpoint)")
        
        guard let url = URL(string: baseURL + endpoint) else {
            throw NetworkError.invalidURL
        }
        
        let (data, response) = try await session.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse,
              200...299 ~= httpResponse.statusCode else {
            throw NetworkError.serverError
        }
        
        log.info("GET ÏùëÎãµ ÏÑ±Í≥µ: \(endpoint)")
        return try JSONDecoder().decode(T.self, from: data)
    }
    
    func post<T: Codable, U: Codable>(_ endpoint: String, body: T) async throws -> U {
        let log = await logger()
        log.info("POST ÏöîÏ≤≠: \(endpoint)")
        
        guard let url = URL(string: baseURL + endpoint) else {
            throw NetworkError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try JSONEncoder().encode(body)
        
        let (data, response) = try await session.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              200...299 ~= httpResponse.statusCode else {
            throw NetworkError.serverError
        }
        
        log.info("POST ÏùëÎãµ ÏÑ±Í≥µ: \(endpoint)")
        return try JSONDecoder().decode(U.self, from: data)
    }
}

enum NetworkError: Error, LocalizedError {
    case invalidURL
    case serverError
    case noData
    
    var errorDescription: String? {
        switch self {
        case .invalidURL: return "ÏûòÎ™ªÎêú URLÏûÖÎãàÎã§"
        case .serverError: return "ÏÑúÎ≤Ñ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§"
        case .noData: return "Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§"
        }
    }
}

struct NetworkClientKey: DependencyKey {
    typealias Value = NetworkClient
    static var defaultValue: NetworkClient {
        MockNetworkClient()
    }
}

// Mock ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏
final class MockNetworkClient: NetworkClient {
    func get<T: Codable>(_ endpoint: String) async throws -> T {
        // Mock Îç∞Ïù¥ÌÑ∞ Î∞òÌôò Î°úÏßÅ
        if T.self == User.self {
            return User.mock as! T
        }
        throw NetworkError.noData
    }
    
    func post<T: Codable, U: Codable>(_ endpoint: String, body: T) async throws -> U {
        // Mock ÏùëÎãµ Î∞òÌôò Î°úÏßÅ
        if U.self == User.self {
            return User.mock as! U
        }
        throw NetworkError.noData
    }
}
```

**3.2 ÎÑ§Ìä∏ÏõåÌÅ¨ Î™®Îìà ÏÉùÏÑ±**
```swift
struct NetworkModule: Module {
    let environment: AppEnvironment
    
    init(environment: AppEnvironment = .development) {
        self.environment = environment
    }
    
    func configure(_ builder: WeaverBuilder) async {
        // ÌôòÍ≤ΩÎ≥Ñ Î≤†Ïù¥Ïä§ URL ÏÑ§Ï†ï
        let baseURL = switch environment {
        case .production: "https://api.myapp.com"
        case .staging: "https://staging-api.myapp.com"
        case .development: "https://dev-api.myapp.com"
        }
        
        await builder.register(NetworkClientKey.self, scope: .shared) { _ in
            URLSessionNetworkClient(baseURL: baseURL)
        }
    }
}

enum AppEnvironment {
    case production
    case staging
    case development
}
```

**3.3 ÏÇ¨Ïö©Ïûê ÏÑúÎπÑÏä§ ÏóÖÎç∞Ïù¥Ìä∏ (ÎÑ§Ìä∏ÏõåÌÅ¨ ÏùòÏ°¥ÏÑ± Ï∂îÍ∞Ä)**
```swift
final class APIUserService: UserService {
    @Inject(LoggerKey.self) private var logger
    @Inject(NetworkClientKey.self) private var networkClient
    
    func getCurrentUser() async throws -> User? {
        let log = await logger()
        let client = await networkClient()
        
        log.info("ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ API Ìò∏Ï∂ú ÏãúÏûë")
        
        do {
            let user: User = try await client.get("/user/me")
            log.info("ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ API Ìò∏Ï∂ú ÏÑ±Í≥µ")
            return user
        } catch {
            log.error("ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ API Ìò∏Ï∂ú Ïã§Ìå®: \(error)")
            throw error
        }
    }
    
    func updateProfile(name: String, email: String) async throws {
        let log = await logger()
        let client = await networkClient()
        
        log.info("ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ API Ìò∏Ï∂ú ÏãúÏûë")
        
        struct UpdateProfileRequest: Codable {
            let name: String
            let email: String
        }
        
        let request = UpdateProfileRequest(name: name, email: email)
        
        do {
            let _: User = try await client.post("/user/profile", body: request)
            log.info("ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ API Ìò∏Ï∂ú ÏÑ±Í≥µ")
        } catch {
            log.error("ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ API Ìò∏Ï∂ú Ïã§Ìå®: \(error)")
            throw error
        }
    }
}
```

**3.4 Î™®Îìà ÌÜµÌï©**
```swift
// App.swift ÏµúÏ¢Ö ÏóÖÎç∞Ïù¥Ìä∏
@main
struct TutorialApp: App {
    init() {
        Task {
            try await Weaver.setup(modules: [
                LoggingModule(),           // Î°úÍπÖ (Îã§Î•∏ Î™®ÎìàÎì§Ïù¥ ÏùòÏ°¥)
                NetworkModule(),           // ÎÑ§Ìä∏ÏõåÌÅ¨ (ÏÇ¨Ïö©Ïûê Î™®ÎìàÏù¥ ÏùòÏ°¥)
                UserModule()               // ÏÇ¨Ïö©Ïûê (ÎÑ§Ìä∏ÏõåÌÅ¨ÏôÄ Î°úÍπÖÏóê ÏùòÏ°¥)
            ])
        }
    }
    
    var body: some Scene {
        WindowGroup {
            UserProfileView()
        }
    }
}
```

#### üí° ÌïµÏã¨ Ìè¨Ïù∏Ìä∏
- Î™®ÎìàÏùÄ Í¥ÄÎ†® ÏùòÏ°¥ÏÑ±Îì§ÏùÑ ÎÖºÎ¶¨Ï†ÅÏúºÎ°ú Í∑∏Î£πÌôîÌï©ÎãàÎã§
- Î™®Îìà Í∞Ñ ÏùòÏ°¥ÏÑ± ÏàúÏÑúÍ∞Ä Ï§ëÏöîÌï©ÎãàÎã§ (Î°úÍπÖ ‚Üí ÎÑ§Ìä∏ÏõåÌÅ¨ ‚Üí ÏÇ¨Ïö©Ïûê)
- ÌôòÍ≤ΩÎ≥Ñ ÏÑ§Ï†ïÏùÑ Î™®ÎìàÏóêÏÑú Ï≤òÎ¶¨Ìï† Ïàò ÏûàÏäµÎãàÎã§
- `scope: .shared`Îäî Ïï± Ï†ÑÏ≤¥ÏóêÏÑú ÌïòÎÇòÏùò Ïù∏Ïä§ÌÑ¥Ïä§Î•º Í≥µÏú†Ìï©ÎãàÎã§

#### üí° Ïä§ÏΩîÌîÑ ÏôÑÏ†Ñ Í∞ÄÏù¥Îìú

WeaverÎäî 5Í∞ÄÏßÄ ÏßÅÍ¥ÄÏ†ÅÏù∏ Ïä§ÏΩîÌîÑÎ•º Ï†úÍ≥µÌï©ÎãàÎã§:

```swift
// üîÑ .shared: Ïï± Ï†ÑÏ≤¥ÏóêÏÑú ÌïòÎÇòÏùò Ïù∏Ïä§ÌÑ¥Ïä§ Í≥µÏú† (Ïã±Í∏ÄÌÜ§)
await builder.register(DatabaseKey.self, scope: .shared) { _ in
    CoreDataManager()
}

// üßπ .weak: ÏïΩÌïú Ï∞∏Ï°∞Î°ú Î©îÎ™®Î¶¨ Ìö®Ïú® Í¥ÄÎ¶¨
await builder.registerWeak(ImageCacheKey.self) { _ in
    ImageCache()
}

// üöÄ .startup: Ïï± ÏãúÏûë Ïãú Ï¶âÏãú Î°úÎî© (ÌïÑÏàò ÏÑúÎπÑÏä§)
await builder.register(LoggerKey.self, scope: .startup) { _ in
    ProductionLogger()
}

// üí§ .whenNeeded: Ïã§Ï†ú ÏÇ¨Ïö©Ìï† ÎïåÎßå Î°úÎî© (ÏßÄÏó∞ Î°úÎî©)
await builder.register(CameraServiceKey.self, scope: .whenNeeded) { _ in
    CameraService()
}

// üîÑ .transient: Îß§Î≤à ÏÉàÎ°úÏö¥ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± (ÏùºÌöåÏÑ±)
await builder.register(DataProcessorKey.self, scope: .transient) { _ in
    DataProcessor()
}
```

**üéâ Ï¥àÍ∏â Î†àÎ≤® ÏôÑÎ£å!** Ïù¥Ï†ú Weaver DIÏùò Í∏∞Î≥∏ Í∞úÎÖêÏùÑ ÏôÑÏ†ÑÌûà Ïù¥Ìï¥ÌñàÏäµÎãàÎã§.

---

## üü° Ï§ëÍ∏â Î†àÎ≤®

### 4Îã®Í≥Ñ: ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÑúÎπÑÏä§ Íµ¨ÌòÑ

#### üéØ ÌïôÏäµ Î™©Ìëú
- Ïã§Ï†ú ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÜµÏã† Íµ¨ÌòÑ
- ÏóêÎü¨ Ï≤òÎ¶¨ Î∞è Ïû¨ÏãúÎèÑ Î°úÏßÅ
- Ï∫êÏã± ÏãúÏä§ÌÖú Íµ¨Ï∂ï

#### üìù Ïã§Ïäµ: ÏôÑÏ†ÑÌïú ÎÑ§Ìä∏ÏõåÌÅ¨ Ïä§ÌÉù

**4.1 Í≥†Í∏â ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏**
```swift
// ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÑ§Ï†ï
struct NetworkConfiguration {
    let baseURL: String
    let timeout: TimeInterval
    let retryCount: Int
    let cachePolicy: URLRequest.CachePolicy
    
    static let `default` = NetworkConfiguration(
        baseURL: "https://jsonplaceholder.typicode.com",
        timeout: 30.0,
        retryCount: 3,
        cachePolicy: .useProtocolCachePolicy
    )
}

// Í≥†Í∏â ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏
final class AdvancedNetworkClient: NetworkClient {
    private let configuration: NetworkConfiguration
    private let session: URLSession
    
    @Inject(LoggerKey.self) private var logger
    
    init(configuration: NetworkConfiguration = .default) {
        self.configuration = configuration
        
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = configuration.timeout
        config.requestCachePolicy = configuration.cachePolicy
        
        self.session = URLSession(configuration: config)
    }
    
    func get<T: Codable>(_ endpoint: String) async throws -> T {
        return try await performRequest(endpoint: endpoint, method: "GET", body: nil as String?)
    }
    
    func post<T: Codable, U: Codable>(_ endpoint: String, body: T) async throws -> U {
        return try await performRequest(endpoint: endpoint, method: "POST", body: body)
    }
    
    private func performRequest<T: Codable, U: Codable>(
        endpoint: String,
        method: String,
        body: T?
    ) async throws -> U {
        let log = await logger()
        
        for attempt in 1...configuration.retryCount {
            do {
                log.info("\(method) ÏöîÏ≤≠ ÏãúÎèÑ \(attempt)/\(configuration.retryCount): \(endpoint)")
                
                guard let url = URL(string: configuration.baseURL + endpoint) else {
                    throw NetworkError.invalidURL
                }
                
                var request = URLRequest(url: url)
                request.httpMethod = method
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                
                if let body = body {
                    request.httpBody = try JSONEncoder().encode(body)
                }
                
                let (data, response) = try await session.data(for: request)
                
                guard let httpResponse = response as? HTTPURLResponse else {
                    throw NetworkError.invalidResponse
                }
                
                switch httpResponse.statusCode {
                case 200...299:
                    log.info("\(method) ÏöîÏ≤≠ ÏÑ±Í≥µ: \(endpoint)")
                    return try JSONDecoder().decode(U.self, from: data)
                case 400...499:
                    throw NetworkError.clientError(httpResponse.statusCode)
                case 500...599:
                    throw NetworkError.serverError(httpResponse.statusCode)
                default:
                    throw NetworkError.unknownError(httpResponse.statusCode)
                }
                
            } catch {
                log.error("\(method) ÏöîÏ≤≠ Ïã§Ìå® (ÏãúÎèÑ \(attempt)): \(error)")
                
                // ÎßàÏßÄÎßâ ÏãúÎèÑÍ∞Ä ÏïÑÎãàÎ©¥ Ïû¨ÏãúÎèÑ
                if attempt < configuration.retryCount {
                    let delay = TimeInterval(attempt * attempt) // ÏßÄÏàò Î∞±Ïò§ÌîÑ
                    try await Task.sleep(for: .seconds(delay))
                    continue
                } else {
                    throw error
                }
            }
        }
        
        throw NetworkError.maxRetriesExceeded
    }
}

// ÌôïÏû•Îêú ÎÑ§Ìä∏ÏõåÌÅ¨ ÏóêÎü¨
enum NetworkError: Error, LocalizedError {
    case invalidURL
    case invalidResponse
    case clientError(Int)
    case serverError(Int)
    case unknownError(Int)
    case maxRetriesExceeded
    case decodingError(Error)
    
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "ÏûòÎ™ªÎêú URLÏûÖÎãàÎã§"
        case .invalidResponse:
            return "ÏûòÎ™ªÎêú ÏùëÎãµÏûÖÎãàÎã§"
        case .clientError(let code):
            return "ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïò§Î•ò (ÏΩîÎìú: \(code))"
        case .serverError(let code):
            return "ÏÑúÎ≤Ñ Ïò§Î•ò (ÏΩîÎìú: \(code))"
        case .unknownError(let code):
            return "Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò (ÏΩîÎìú: \(code))"
        case .maxRetriesExceeded:
            return "ÏµúÎåÄ Ïû¨ÏãúÎèÑ ÌöüÏàòÎ•º Ï¥àÍ≥ºÌñàÏäµÎãàÎã§"
        case .decodingError(let error):
            return "Îç∞Ïù¥ÌÑ∞ ÌååÏã± Ïò§Î•ò: \(error.localizedDescription)"
        }
    }
}
```

Ïù¥Ï†ú ÌäúÌÜ†Î¶¨ÏñºÏùò ÎÇòÎ®∏ÏßÄ Î∂ÄÎ∂ÑÏùÑ Í≥ÑÏÜç ÏûëÏÑ±ÌïòÍ≤†ÏäµÎãàÎã§.**4.2 Ï∫êÏã±
 ÏãúÏä§ÌÖú Íµ¨ÌòÑ**
```swift
// Ï∫êÏãú Ï†ïÏ±Ö
enum CachePolicy {
    case noCache
    case memoryOnly(maxSize: Int)
    case diskAndMemory(maxSize: Int, diskSize: Int)
    case custom(TimeInterval) // Ïª§Ïä§ÌÖÄ ÎßåÎ£å ÏãúÍ∞Ñ
}

// ÏùëÎãµ Ï∫êÏãú Îß§ÎãàÏ†Ä
final class ResponseCacheManager: Sendable {
    private let memoryCache = NSCache<NSString, NSData>()
    private let cachePolicy: CachePolicy
    
    @Inject(LoggerKey.self) private var logger
    
    init(policy: CachePolicy = .memoryOnly(maxSize: 100)) {
        self.cachePolicy = policy
        
        switch policy {
        case .memoryOnly(let maxSize), .diskAndMemory(let maxSize, _):
            memoryCache.countLimit = maxSize
        default:
            break
        }
    }
    
    func get<T: Codable>(_ key: String, type: T.Type) async -> T? {
        let log = await logger()
        
        guard case .noCache = cachePolicy else {
            return nil
        }
        
        if let data = memoryCache.object(forKey: key as NSString) {
            do {
                let object = try JSONDecoder().decode(T.self, from: data as Data)
                log.debug("Ï∫êÏãú ÌûàÌä∏: \(key)")
                return object
            } catch {
                log.error("Ï∫êÏãú ÎîîÏΩîÎî© Ïã§Ìå®: \(error)")
                memoryCache.removeObject(forKey: key as NSString)
            }
        }
        
        log.debug("Ï∫êÏãú ÎØ∏Ïä§: \(key)")
        return nil
    }
    
    func set<T: Codable>(_ key: String, value: T) async {
        let log = await logger()
        
        guard case .noCache = cachePolicy else {
            return
        }
        
        do {
            let data = try JSONEncoder().encode(value)
            memoryCache.setObject(data as NSData, forKey: key as NSString)
            log.debug("Ï∫êÏãú Ï†ÄÏû•: \(key)")
        } catch {
            log.error("Ï∫êÏãú Ïù∏ÏΩîÎî© Ïã§Ìå®: \(error)")
        }
    }
    
    func clear() async {
        memoryCache.removeAllObjects()
        let log = await logger()
        log.info("Ï∫êÏãú Ï†ÑÏ≤¥ ÏÇ≠Ï†ú")
    }
}

struct ResponseCacheManagerKey: DependencyKey {
    typealias Value = ResponseCacheManager
    static var defaultValue: ResponseCacheManager {
        ResponseCacheManager(policy: .memoryOnly(maxSize: 50))
    }
}
```

**4.3 Ï∫êÏãúÎêú ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÑúÎπÑÏä§**
```swift
final class CachedNetworkService: Sendable {
    @Inject(NetworkClientKey.self) private var networkClient
    @Inject(ResponseCacheManagerKey.self) private var cacheManager
    @Inject(LoggerKey.self) private var logger
    
    func getCachedData<T: Codable>(
        _ endpoint: String,
        type: T.Type,
        cacheKey: String? = nil,
        forceRefresh: Bool = false
    ) async throws -> T {
        let key = cacheKey ?? "cached_\(endpoint)"
        let log = await logger()
        
        // Í∞ïÏ†ú ÏÉàÎ°úÍ≥†Ïπ®Ïù¥ ÏïÑÎãàÎ©¥ Ï∫êÏãú ÌôïÏù∏
        if !forceRefresh {
            let cache = await cacheManager()
            if let cachedData = await cache.get(key, type: T.self) {
                log.info("Ï∫êÏãúÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Î∞òÌôò: \(endpoint)")
                return cachedData
            }
        }
        
        // Ï∫êÏãú ÎØ∏Ïä§ ÎòêÎäî Í∞ïÏ†ú ÏÉàÎ°úÍ≥†Ïπ® Ïãú ÎÑ§Ìä∏ÏõåÌÅ¨ ÏöîÏ≤≠
        let client = await networkClient()
        let data: T = try await client.get(endpoint)
        
        // ÏùëÎãµÏùÑ Ï∫êÏãúÏóê Ï†ÄÏû•
        let cache = await cacheManager()
        await cache.set(key, value: data)
        
        log.info("ÎÑ§Ìä∏ÏõåÌÅ¨ÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏ÏôÄÏÑú Ï∫êÏãú Ï†ÄÏû•: \(endpoint)")
        return data
    }
    
    func postWithCache<T: Codable, U: Codable>(
        _ endpoint: String,
        body: T,
        responseType: U.Type,
        invalidateCacheKeys: [String] = []
    ) async throws -> U {
        let client = await networkClient()
        let response: U = try await client.post(endpoint, body: body)
        
        // POST ÏÑ±Í≥µ Ïãú Í¥ÄÎ†® Ï∫êÏãú Î¨¥Ìö®Ìôî
        if !invalidateCacheKeys.isEmpty {
            let cache = await cacheManager()
            let log = await logger()
            
            for key in invalidateCacheKeys {
                // Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî ÌäπÏ†ï ÌÇ§Îßå ÏÇ≠Ï†úÌïòÎäî Î©îÏÑúÎìú ÌïÑÏöî
                log.info("Ï∫êÏãú Î¨¥Ìö®Ìôî: \(key)")
            }
        }
        
        return response
    }
}

struct CachedNetworkServiceKey: DependencyKey {
    typealias Value = CachedNetworkService
    static var defaultValue: CachedNetworkService { CachedNetworkService() }
}
```

**4.4 ÏóÖÎç∞Ïù¥Ìä∏Îêú ÎÑ§Ìä∏ÏõåÌÅ¨ Î™®Îìà**
```swift
struct NetworkModule: Module {
    let environment: AppEnvironment
    let cachePolicy: CachePolicy
    
    init(environment: AppEnvironment = .development, cachePolicy: CachePolicy = .memoryOnly(maxSize: 100)) {
        self.environment = environment
        self.cachePolicy = cachePolicy
    }
    
    func configure(_ builder: WeaverBuilder) async {
        // ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÑ§Ï†ï
        let config = NetworkConfiguration(
            baseURL: environment.baseURL,
            timeout: 30.0,
            retryCount: environment == .production ? 3 : 1,
            cachePolicy: .useProtocolCachePolicy
        )
        
        // Í∏∞Î≥∏ ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏
        await builder.register(NetworkClientKey.self, scope: .shared) { _ in
            AdvancedNetworkClient(configuration: config)
        }
        
        // Ï∫êÏãú Îß§ÎãàÏ†Ä
        await builder.register(ResponseCacheManagerKey.self, scope: .shared) { _ in
            ResponseCacheManager(policy: cachePolicy)
        }
        
        // Ï∫êÏãúÎêú ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÑúÎπÑÏä§
        await builder.register(CachedNetworkServiceKey.self, scope: .shared) { _ in
            CachedNetworkService()
        }
    }
}

extension AppEnvironment {
    var baseURL: String {
        switch self {
        case .production: return "https://api.myapp.com"
        case .staging: return "https://staging-api.myapp.com"
        case .development: return "https://jsonplaceholder.typicode.com"
        }
    }
}
```

**4.5 ÏÇ¨Ïö©Ïûê ÏÑúÎπÑÏä§ ÏµúÏ¢Ö ÏóÖÎç∞Ïù¥Ìä∏**
```swift
final class APIUserService: UserService {
    @Inject(CachedNetworkServiceKey.self) private var cachedNetworkService
    @Inject(LoggerKey.self) private var logger
    
    func getCurrentUser() async throws -> User? {
        let log = await logger()
        log.info("ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏöîÏ≤≠ ÏãúÏûë")
        
        do {
            let service = await cachedNetworkService()
            // JSONPlaceholder API ÏÇ¨Ïö© (Ïã§Ï†ú Ïï±ÏóêÏÑúÎäî /user/me)
            let user = try await service.getCachedData("/users/1", type: User.self)
            
            log.info("ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏöîÏ≤≠ ÏÑ±Í≥µ")
            return user
        } catch {
            log.error("ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏöîÏ≤≠ Ïã§Ìå®: \(error)")
            throw error
        }
    }
    
    func updateProfile(name: String, email: String) async throws {
        let log = await logger()
        log.info("ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ ÏöîÏ≤≠ ÏãúÏûë")
        
        struct UpdateRequest: Codable {
            let name: String
            let email: String
        }
        
        do {
            let service = await cachedNetworkService()
            let request = UpdateRequest(name: name, email: email)
            
            // ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ ÌõÑ ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï∫êÏãú Î¨¥Ìö®Ìôî
            let _: User = try await service.postWithCache(
                "/users/1",
                body: request,
                responseType: User.self,
                invalidateCacheKeys: ["cached_/users/1"]
            )
            
            log.info("ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ ÏÑ±Í≥µ")
        } catch {
            log.error("ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®: \(error)")
            throw error
        }
    }
}
```

#### üí° ÌïµÏã¨ Ìè¨Ïù∏Ìä∏
- ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Îäî Ïû¨ÏãúÎèÑ Î°úÏßÅÍ≥º ÏßÄÏàò Î∞±Ïò§ÌîÑÎ•º Íµ¨ÌòÑÌï©ÎãàÎã§
- Ï∫êÏã± ÏãúÏä§ÌÖúÏúºÎ°ú ÏÑ±Îä•ÏùÑ ÌÅ¨Í≤å Ìñ•ÏÉÅÏãúÌÇ¨ Ïàò ÏûàÏäµÎãàÎã§
- POST ÏöîÏ≤≠ ÌõÑ Í¥ÄÎ†® Ï∫êÏãúÎ•º Î¨¥Ìö®ÌôîÌïòÏó¨ Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ±ÏùÑ Ïú†ÏßÄÌï©ÎãàÎã§
- ÌôòÍ≤ΩÎ≥ÑÎ°ú Îã§Î•∏ ÏÑ§Ï†ïÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§

---

### 5Îã®Í≥Ñ: ÏóêÎü¨ Ï≤òÎ¶¨ÏôÄ ÏïàÏ†ÑÏÑ±

#### üéØ ÌïôÏäµ Î™©Ìëú
- Íµ¨Ï°∞ÌôîÎêú ÏóêÎü¨ Ï≤òÎ¶¨ ÏãúÏä§ÌÖú
- ÏÇ¨Ïö©Ïûê ÏπúÌôîÏ†Å ÏóêÎü¨ Î©îÏãúÏßÄ
- ÏóêÎü¨ Î≥µÍµ¨ Ï†ÑÎûµ

#### üìù Ïã§Ïäµ: ÏôÑÏ†ÑÌïú ÏóêÎü¨ Ï≤òÎ¶¨ ÏãúÏä§ÌÖú

**5.1 Ïï± Ï†ÑÏ≤¥ ÏóêÎü¨ ÌÉÄÏûÖ Ï†ïÏùò**
```swift
// Ïï± Î†àÎ≤® ÏóêÎü¨
enum AppError: Error, LocalizedError {
    case network(NetworkError)
    case user(UserError)
    case cache(CacheError)
    case unknown(Error)
    
    var errorDescription: String? {
        switch self {
        case .network(let error):
            return "ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò: \(error.localizedDescription)"
        case .user(let error):
            return "ÏÇ¨Ïö©Ïûê Ïò§Î•ò: \(error.localizedDescription)"
        case .cache(let error):
            return "Ï∫êÏãú Ïò§Î•ò: \(error.localizedDescription)"
        case .unknown(let error):
            return "Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò: \(error.localizedDescription)"
        }
    }
    
    var recoverySuggestion: String? {
        switch self {
        case .network(.maxRetriesExceeded):
            return "ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏ÌïòÍ≥† Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî."
        case .network(.serverError):
            return "Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî."
        case .user(.invalidInput):
            return "ÏûÖÎ†• Ï†ïÎ≥¥Î•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî."
        default:
            return "Ïï±ÏùÑ Îã§Ïãú ÏãúÏûëÌï¥Î≥¥ÏÑ∏Ïöî."
        }
    }
}

// ÏÇ¨Ïö©Ïûê Í¥ÄÎ†® ÏóêÎü¨
enum UserError: Error, LocalizedError {
    case notFound
    case invalidInput
    case unauthorized
    case profileUpdateFailed
    
    var errorDescription: String? {
        switch self {
        case .notFound:
            return "ÏÇ¨Ïö©ÏûêÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§"
        case .invalidInput:
            return "ÏûÖÎ†• Ï†ïÎ≥¥Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§"
        case .unauthorized:
            return "Ïù∏Ï¶ùÏù¥ ÌïÑÏöîÌï©ÎãàÎã§"
        case .profileUpdateFailed:
            return "ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§"
        }
    }
}

// Ï∫êÏãú Í¥ÄÎ†® ÏóêÎü¨
enum CacheError: Error, LocalizedError {
    case encodingFailed
    case decodingFailed
    case storageError
    
    var errorDescription: String? {
        switch self {
        case .encodingFailed:
            return "Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§"
        case .decodingFailed:
            return "Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§"
        case .storageError:
            return "Ï†ÄÏû•ÏÜå Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§"
        }
    }
}
```

**5.2 ÏóêÎü¨ Ï≤òÎ¶¨ ÏÑúÎπÑÏä§**
```swift
protocol ErrorHandlingService: Sendable {
    func handleError(_ error: Error) async -> AppError
    func shouldRetry(_ error: AppError) -> Bool
    func getRetryDelay(_ error: AppError, attempt: Int) -> TimeInterval
}

final class DefaultErrorHandlingService: ErrorHandlingService {
    @Inject(LoggerKey.self) private var logger
    
    func handleError(_ error: Error) async -> AppError {
        let log = await logger()
        
        let appError: AppError
        
        switch error {
        case let networkError as NetworkError:
            appError = .network(networkError)
        case let userError as UserError:
            appError = .user(userError)
        case let cacheError as CacheError:
            appError = .cache(cacheError)
        default:
            appError = .unknown(error)
        }
        
        log.error("ÏóêÎü¨ Ï≤òÎ¶¨: \(appError.localizedDescription)")
        return appError
    }
    
    func shouldRetry(_ error: AppError) -> Bool {
        switch error {
        case .network(.serverError), .network(.unknownError):
            return true
        case .cache(.storageError):
            return true
        default:
            return false
        }
    }
    
    func getRetryDelay(_ error: AppError, attempt: Int) -> TimeInterval {
        // ÏßÄÏàò Î∞±Ïò§ÌîÑ: 1Ï¥à, 2Ï¥à, 4Ï¥à, 8Ï¥à...
        return TimeInterval(min(pow(2.0, Double(attempt)), 30.0))
    }
}

struct ErrorHandlingServiceKey: DependencyKey {
    typealias Value = ErrorHandlingService
    static var defaultValue: ErrorHandlingService { DefaultErrorHandlingService() }
}
```

**5.3 ÏóêÎü¨ Î≥µÍµ¨ Í∞ÄÎä•Ìïú ÏÇ¨Ïö©Ïûê ÏÑúÎπÑÏä§**
```swift
final class ResilientUserService: UserService {
    @Inject(CachedNetworkServiceKey.self) private var cachedNetworkService
    @Inject(ErrorHandlingServiceKey.self) private var errorHandlingService
    @Inject(LoggerKey.self) private var logger
    
    private let maxRetryAttempts = 3
    
    func getCurrentUser() async throws -> User? {
        return try await performWithRetry { [weak self] in
            guard let self = self else { throw UserError.notFound }
            
            let service = await self.cachedNetworkService()
            return try await service.getCachedData("/users/1", type: User.self)
        }
    }
    
    func updateProfile(name: String, email: String) async throws {
        // ÏûÖÎ†• Í≤ÄÏ¶ù
        guard !name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            throw UserError.invalidInput
        }
        
        guard email.contains("@") && email.contains(".") else {
            throw UserError.invalidInput
        }
        
        struct UpdateRequest: Codable {
            let name: String
            let email: String
        }
        
        let request = UpdateRequest(name: name, email: email)
        
        let _: User = try await performWithRetry { [weak self] in
            guard let self = self else { throw UserError.profileUpdateFailed }
            
            let service = await self.cachedNetworkService()
            return try await service.postWithCache(
                "/users/1",
                body: request,
                responseType: User.self,
                invalidateCacheKeys: ["cached_/users/1"]
            )
        }
    }
    
    private func performWithRetry<T>(
        operation: @escaping () async throws -> T
    ) async throws -> T {
        let log = await logger()
        let errorHandler = await errorHandlingService()
        
        for attempt in 1...maxRetryAttempts {
            do {
                return try await operation()
            } catch {
                let appError = await errorHandler.handleError(error)
                
                // ÎßàÏßÄÎßâ ÏãúÎèÑÏù¥Í±∞ÎÇò Ïû¨ÏãúÎèÑ Î∂àÍ∞ÄÎä•Ìïú ÏóêÎü¨Î©¥ ÎçòÏßÄÍ∏∞
                if attempt == maxRetryAttempts || !errorHandler.shouldRetry(appError) {
                    log.error("ÏµúÏ¢Ö Ïã§Ìå® (ÏãúÎèÑ \(attempt)/\(maxRetryAttempts)): \(appError)")
                    throw appError
                }
                
                // Ïû¨ÏãúÎèÑ ÎåÄÍ∏∞
                let delay = errorHandler.getRetryDelay(appError, attempt: attempt)
                log.info("Ïû¨ÏãúÎèÑ ÎåÄÍ∏∞ \(delay)Ï¥à (ÏãúÎèÑ \(attempt)/\(maxRetryAttempts))")
                
                try await Task.sleep(for: .seconds(delay))
            }
        }
        
        throw UserError.profileUpdateFailed
    }
}
```

**5.4 ÏóêÎü¨ ÌëúÏãú UI Ïª¥Ìè¨ÎÑåÌä∏**
```swift
// ÏóêÎü¨ ÏÉÅÌÉúÎ•º Í¥ÄÎ¶¨ÌïòÎäî ObservableObject
@MainActor
class ErrorViewModel: ObservableObject {
    @Published var currentError: AppError?
    @Published var isShowingError = false
    
    @Inject(ErrorHandlingServiceKey.self) private var errorHandlingService
    @Inject(LoggerKey.self) private var logger
    
    func handleError(_ error: Error) async {
        let handler = await errorHandlingService()
        let appError = await handler.handleError(error)
        
        await MainActor.run {
            self.currentError = appError
            self.isShowingError = true
        }
    }
    
    func dismissError() {
        currentError = nil
        isShowingError = false
    }
    
    func canRetry() -> Bool {
        guard let error = currentError else { return false }
        
        Task {
            let handler = await errorHandlingService()
            return handler.shouldRetry(error)
        }
        
        return false
    }
}

// ÏóêÎü¨ ÌëúÏãú View
struct ErrorView: View {
    let error: AppError
    let onRetry: (() -> Void)?
    let onDismiss: () -> Void
    
    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: "exclamationmark.triangle")
                .font(.system(size: 50))
                .foregroundColor(.red)
            
            Text("Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§")
                .font(.title2)
                .fontWeight(.bold)
            
            Text(error.localizedDescription)
                .font(.body)
                .multilineTextAlignment(.center)
                .foregroundColor(.secondary)
            
            if let suggestion = error.recoverySuggestion {
                Text(suggestion)
                    .font(.caption)
                    .multilineTextAlignment(.center)
                    .foregroundColor(.secondary)
                    .padding(.horizontal)
            }
            
            HStack(spacing: 12) {
                Button("ÌôïÏù∏") {
                    onDismiss()
                }
                .buttonStyle(.bordered)
                
                if let onRetry = onRetry {
                    Button("Îã§Ïãú ÏãúÎèÑ") {
                        onRetry()
                    }
                    .buttonStyle(.borderedProminent)
                }
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 10)
    }
}
```

**5.5 ÏóêÎü¨ Ï≤òÎ¶¨Í∞Ä ÌÜµÌï©Îêú ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ View**
```swift
struct ResilientUserProfileView: View {
    @StateObject private var errorViewModel = ErrorViewModel()
    @Inject(UserServiceKey.self) private var userService
    
    @State private var user: User?
    @State private var isLoading = false
    @State private var isEditing = false
    @State private var editName = ""
    @State private var editEmail = ""
    
    var body: some View {
        NavigationView {
            ZStack {
                VStack(spacing: 20) {
                    if isLoading {
                        ProgressView("Î°úÎî© Ï§ë...")
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                    } else if let user = user {
                        userInfoView(user)
                    } else {
                        emptyStateView()
                    }
                }
                .navigationTitle("ÌîÑÎ°úÌïÑ")
                .toolbar {
                    if user != nil && !isLoading {
                        Button(isEditing ? "ÏôÑÎ£å" : "Ìé∏Ïßë") {
                            if isEditing {
                                Task { await saveProfile() }
                            } else {
                                startEditing()
                            }
                        }
                    }
                }
                
                // ÏóêÎü¨ Ïò§Î≤ÑÎ†àÏù¥
                if errorViewModel.isShowingError {
                    Color.black.opacity(0.3)
                        .ignoresSafeArea()
                        .onTapGesture {
                            errorViewModel.dismissError()
                        }
                    
                    if let error = errorViewModel.currentError {
                        ErrorView(
                            error: error,
                            onRetry: errorViewModel.canRetry() ? {
                                errorViewModel.dismissError()
                                Task { await loadUser() }
                            } : nil,
                            onDismiss: {
                                errorViewModel.dismissError()
                            }
                        )
                        .padding()
                    }
                }
            }
        }
        .task {
            await loadUser()
        }
    }
    
    @ViewBuilder
    private func userInfoView(_ user: User) -> some View {
        VStack(spacing: 16) {
            // ÏïÑÎ∞îÌÉÄ
            AsyncImage(url: user.avatarURL.flatMap(URL.init)) { image in
                image
                    .resizable()
                    .aspectRatio(contentMode: .fill)
            } placeholder: {
                Image(systemName: "person.circle.fill")
                    .font(.system(size: 80))
                    .foregroundColor(.gray)
            }
            .frame(width: 100, height: 100)
            .clipShape(Circle())
            
            // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥
            if isEditing {
                VStack(spacing: 12) {
                    TextField("Ïù¥Î¶Ñ", text: $editName)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                    
                    TextField("Ïù¥Î©îÏùº", text: $editEmail)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .keyboardType(.emailAddress)
                        .autocapitalization(.none)
                }
                .padding(.horizontal)
            } else {
                VStack(spacing: 8) {
                    Text(user.name)
                        .font(.title2)
                        .fontWeight(.bold)
                    
                    Text(user.email)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
            }
            
            Spacer()
        }
        .padding()
    }
    
    @ViewBuilder
    private func emptyStateView() -> some View {
        VStack(spacing: 16) {
            Image(systemName: "person.slash")
                .font(.system(size: 60))
                .foregroundColor(.gray)
            
            Text("ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§")
                .font(.title3)
                .foregroundColor(.secondary)
            
            Button("Îã§Ïãú ÏãúÎèÑ") {
                Task { await loadUser() }
            }
            .buttonStyle(.borderedProminent)
        }
    }
    
    private func loadUser() async {
        isLoading = true
        defer { isLoading = false }
        
        do {
            let service = await userService()
            user = try await service.getCurrentUser()
        } catch {
            await errorViewModel.handleError(error)
        }
    }
    
    private func startEditing() {
        guard let user = user else { return }
        editName = user.name
        editEmail = user.email
        isEditing = true
    }
    
    private func saveProfile() async {
        isLoading = true
        defer { isLoading = false }
        
        do {
            let service = await userService()
            try await service.updateProfile(name: editName, email: editEmail)
            
            // ÏÑ±Í≥µ Ïãú Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
            user = User(id: user?.id ?? "", name: editName, email: editEmail, avatarURL: user?.avatarURL)
            isEditing = false
        } catch {
            await errorViewModel.handleError(error)
        }
    }
}
```

**5.6 ÏóêÎü¨ Ï≤òÎ¶¨ Î™®Îìà**
```swift
struct ErrorHandlingModule: Module {
    func configure(_ builder: WeaverBuilder) async {
        await builder.register(ErrorHandlingServiceKey.self, scope: .shared) { _ in
            DefaultErrorHandlingService()
        }
    }
}

// ÏÇ¨Ïö©Ïûê Î™®Îìà ÏóÖÎç∞Ïù¥Ìä∏
struct UserModule: Module {
    func configure(_ builder: WeaverBuilder) async {
        await builder.register(UserServiceKey.self, scope: .shared) { _ in
            ResilientUserService() // ÏóêÎü¨ Î≥µÍµ¨ Í∞ÄÎä•Ìïú ÏÑúÎπÑÏä§Î°ú Î≥ÄÍ≤Ω
        }
    }
}
```

#### üí° ÌïµÏã¨ Ìè¨Ïù∏Ìä∏
- Íµ¨Ï°∞ÌôîÎêú ÏóêÎü¨ ÌÉÄÏûÖÏúºÎ°ú Î™ÖÌôïÌïú ÏóêÎü¨ Ï≤òÎ¶¨
- ÏûêÎèô Ïû¨ÏãúÎèÑ Î°úÏßÅÏúºÎ°ú ÏùºÏãúÏ†Å Ïò§Î•ò Ìï¥Í≤∞
- ÏÇ¨Ïö©Ïûê ÏπúÌôîÏ†ÅÏù∏ ÏóêÎü¨ Î©îÏãúÏßÄÏôÄ Î≥µÍµ¨ Ï†úÏïà
- ÏóêÎü¨ ÏÉÅÌÉúÎ•º Î≥ÑÎèÑ ViewModelÎ°ú Í¥ÄÎ¶¨ÌïòÏó¨ Ïû¨ÏÇ¨Ïö©ÏÑ± Ìñ•ÏÉÅ

---

### 6Îã®Í≥Ñ: ÌÖåÏä§Ìä∏ ÏûëÏÑ±ÌïòÍ∏∞

#### üéØ ÌïôÏäµ Î™©Ìëú
- ÏùòÏ°¥ÏÑ± Ï£ºÏûÖÏùÑ ÌôúÏö©Ìïú ÌÖåÏä§Ìä∏ ÏûëÏÑ±
- Mock Í∞ùÏ≤¥ ÏÉùÏÑ± Î∞è ÏÇ¨Ïö©
- Í≤©Î¶¨Îêú ÌÖåÏä§Ìä∏ ÌôòÍ≤Ω Íµ¨Ï∂ï

#### üìù Ïã§Ïäµ: ÏôÑÏ†ÑÌïú ÌÖåÏä§Ìä∏ Ïä§ÏúÑÌä∏

**6.1 ÌÖåÏä§Ìä∏Ïö© Mock ÏÑúÎπÑÏä§Îì§**
```swift
// Tests/TutorialTests/Mocks/MockServices.swift
import XCTest
@testable import Tutorial
import Weaver

// Mock Î°úÍ±∞
final class MockLogger: Logger {
    private(set) var infoMessages: [String] = []
    private(set) var errorMessages: [String] = []
    private(set) var debugMessages: [String] = []
    
    func info(_ message: String) {
        infoMessages.append(message)
    }
    
    func error(_ message: String) {
        errorMessages.append(message)
    }
    
    func debug(_ message: String) {
        debugMessages.append(message)
    }
    
    func reset() {
        infoMessages.removeAll()
        errorMessages.removeAll()
        debugMessages.removeAll()
    }
}

// Mock ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏
final class MockNetworkClient: NetworkClient {
    var shouldFail = false
    var failureError: Error = NetworkError.serverError(500)
    var getResponses: [String: Any] = [:]
    var postResponses: [String: Any] = [:]
    
    private(set) var getRequests: [String] = []
    private(set) var postRequests: [(endpoint: String, body: Any)] = []
    
    func get<T: Codable>(_ endpoint: String) async throws -> T {
        getRequests.append(endpoint)
        
        if shouldFail {
            throw failureError
        }
        
        guard let response = getResponses[endpoint] as? T else {
            throw NetworkError.invalidResponse
        }
        
        return response
    }
    
    func post<T: Codable, U: Codable>(_ endpoint: String, body: T) async throws -> U {
        postRequests.append((endpoint, body))
        
        if shouldFail {
            throw failureError
        }
        
        guard let response = postResponses[endpoint] as? U else {
            throw NetworkError.invalidResponse
        }
        
        return response
    }
    
    func reset() {
        shouldFail = false
        getResponses.removeAll()
        postResponses.removeAll()
        getRequests.removeAll()
        postRequests.removeAll()
    }
}

// Mock Ï∫êÏãú Îß§ÎãàÏ†Ä
final class MockCacheManager: ResponseCacheManager {
    private var storage: [String: Any] = [:]
    private(set) var getRequests: [String] = []
    private(set) var setRequests: [(key: String, value: Any)] = []
    
    override func get<T: Codable>(_ key: String, type: T.Type) async -> T? {
        getRequests.append(key)
        return storage[key] as? T
    }
    
    override func set<T: Codable>(_ key: String, value: T) async {
        setRequests.append((key, value))
        storage[key] = value
    }
    
    override func clear() async {
        storage.removeAll()
    }
    
    func reset() {
        storage.removeAll()
        getRequests.removeAll()
        setRequests.removeAll()
    }
}
```

**6.2 ÌÖåÏä§Ìä∏ Ìó¨Ìçº Î∞è Î≤†Ïù¥Ïä§ ÌÅ¥ÎûòÏä§**
```swift
// Tests/TutorialTests/TestHelpers/TestHelpers.swift
import XCTest
@testable import Tutorial
import Weaver

class WeaverTestCase: XCTestCase {
    var testContainer: WeaverContainer!
    var mockLogger: MockLogger!
    var mockNetworkClient: MockNetworkClient!
    var mockCacheManager: MockCacheManager!
    
    override func setUp() async throws {
        try await super.setUp()
        
        // Mock Í∞ùÏ≤¥Îì§ ÏÉùÏÑ±
        mockLogger = MockLogger()
        mockNetworkClient = MockNetworkClient()
        mockCacheManager = MockCacheManager()
        
        // ÌÖåÏä§Ìä∏Ïö© Ïª®ÌÖåÏù¥ÎÑà ÏÉùÏÑ±
        testContainer = await WeaverContainer.builder()
            .override(LoggerKey.self) { _ in self.mockLogger }
            .override(NetworkClientKey.self) { _ in self.mockNetworkClient }
            .override(ResponseCacheManagerKey.self) { _ in self.mockCacheManager }
            .override(ErrorHandlingServiceKey.self) { _ in DefaultErrorHandlingService() }
            .build()
        
        // Ï†ÑÏó≠ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        await Weaver.resetForTesting()
    }
    
    override func tearDown() async throws {
        // Mock Í∞ùÏ≤¥Îì§ Ï†ïÎ¶¨
        mockLogger?.reset()
        mockNetworkClient?.reset()
        mockCacheManager?.reset()
        
        testContainer = nil
        mockLogger = nil
        mockNetworkClient = nil
        mockCacheManager = nil
        
        await Weaver.resetForTesting()
        try await super.tearDown()
    }
    
    /// ÌÖåÏä§Ìä∏ Ïª®ÌÖåÏù¥ÎÑà Ïä§ÏΩîÌîÑÏóêÏÑú ÏûëÏóÖ Ïã§Ìñâ
    func withTestScope<T>(_ operation: @escaping () async throws -> T) async throws -> T {
        return try await Weaver.withScope(testContainer) {
            try await operation()
        }
    }
}

// ÌÖåÏä§Ìä∏ Îç∞Ïù¥ÌÑ∞ Ìå©ÌÜ†Î¶¨
struct TestDataFactory {
    static let sampleUser = User(
        id: "test-user-1",
        name: "ÌÖåÏä§Ìä∏ ÏÇ¨Ïö©Ïûê",
        email: "test@example.com",
        avatarURL: "https://example.com/avatar.jpg"
    )
    
    static let updatedUser = User(
        id: "test-user-1",
        name: "ÏóÖÎç∞Ïù¥Ìä∏Îêú ÏÇ¨Ïö©Ïûê",
        email: "updated@example.com",
        avatarURL: "https://example.com/avatar.jpg"
    )
    
    static func createUsers(count: Int) -> [User] {
        return (1...count).map { index in
            User(
                id: "test-user-\(index)",
                name: "ÌÖåÏä§Ìä∏ ÏÇ¨Ïö©Ïûê \(index)",
                email: "test\(index)@example.com",
                avatarURL: nil
            )
        }
    }
}
```

**6.3 ÏÇ¨Ïö©Ïûê ÏÑúÎπÑÏä§ ÌÖåÏä§Ìä∏**
```swift
// Tests/TutorialTests/Services/UserServiceTests.swift
import XCTest
@testable import Tutorial
import Weaver

final class UserServiceTests: WeaverTestCase {
    
    func testGetCurrentUser_Success() async throws {
        // Given
        let expectedUser = TestDataFactory.sampleUser
        mockNetworkClient.getResponses["/users/1"] = expectedUser
        
        // When
        let result = try await withTestScope {
            let service = ResilientUserService()
            return try await service.getCurrentUser()
        }
        
        // Then
        XCTAssertEqual(result?.id, expectedUser.id)
        XCTAssertEqual(result?.name, expectedUser.name)
        XCTAssertEqual(result?.email, expectedUser.email)
        
        // ÎÑ§Ìä∏ÏõåÌÅ¨ ÏöîÏ≤≠Ïù¥ Ïò¨Î∞îÎ•¥Í≤å Ìò∏Ï∂úÎêòÏóàÎäîÏßÄ ÌôïÏù∏
        XCTAssertEqual(mockNetworkClient.getRequests.count, 1)
        XCTAssertEqual(mockNetworkClient.getRequests.first, "/users/1")
        
        // Î°úÍ∑∏Í∞Ä Ïò¨Î∞îÎ•¥Í≤å Í∏∞Î°ùÎêòÏóàÎäîÏßÄ ÌôïÏù∏
        XCTAssertTrue(mockLogger.infoMessages.contains { $0.contains("ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏöîÏ≤≠ ÏãúÏûë") })
        XCTAssertTrue(mockLogger.infoMessages.contains { $0.contains("ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏöîÏ≤≠ ÏÑ±Í≥µ") })
    }
    
    func testGetCurrentUser_NetworkError_WithRetry() async throws {
        // Given
        mockNetworkClient.shouldFail = true
        mockNetworkClient.failureError = NetworkError.serverError(500)
        
        // When & Then
        await withTestScope {
            let service = ResilientUserService()
            
            do {
                _ = try await service.getCurrentUser()
                XCTFail("ÏóêÎü¨Í∞Ä Î∞úÏÉùÌï¥Ïïº Ìï©ÎãàÎã§")
            } catch {
                // ÏóêÎü¨Í∞Ä AppErrorÎ°ú ÎûòÌïëÎêòÏóàÎäîÏßÄ ÌôïÏù∏
                XCTAssertTrue(error is AppError)
                
                if case .network(let networkError) = error as? AppError {
                    XCTAssertTrue(networkError is NetworkError)
                } else {
                    XCTFail("NetworkErrorÎ°ú ÎûòÌïëÎêòÏñ¥Ïïº Ìï©ÎãàÎã§")
                }
            }
        }
        
        // Ïû¨ÏãúÎèÑÍ∞Ä 3Î≤à ÏàòÌñâÎêòÏóàÎäîÏßÄ ÌôïÏù∏
        XCTAssertEqual(mockNetworkClient.getRequests.count, 3)
        
        // ÏóêÎü¨ Î°úÍ∑∏Í∞Ä Í∏∞Î°ùÎêòÏóàÎäîÏßÄ ÌôïÏù∏
        XCTAssertTrue(mockLogger.errorMessages.contains { $0.contains("ÏµúÏ¢Ö Ïã§Ìå®") })
    }
    
    func testGetCurrentUser_CacheHit() async throws {
        // Given
        let expectedUser = TestDataFactory.sampleUser
        let cacheKey = "cached_/users/1"
        
        // Ï∫êÏãúÏóê Îç∞Ïù¥ÌÑ∞ ÎØ∏Î¶¨ Ï†ÄÏû•
        await mockCacheManager.set(cacheKey, value: expectedUser)
        
        // When
        let result = try await withTestScope {
            let service = ResilientUserService()
            return try await service.getCurrentUser()
        }
        
        // Then
        XCTAssertEqual(result?.id, expectedUser.id)
        
        // ÎÑ§Ìä∏ÏõåÌÅ¨ ÏöîÏ≤≠Ïù¥ Ìò∏Ï∂úÎêòÏßÄ ÏïäÏïòÎäîÏßÄ ÌôïÏù∏ (Ï∫êÏãú ÌûàÌä∏)
        XCTAssertEqual(mockNetworkClient.getRequests.count, 0)
        
        // Ï∫êÏãú Ï°∞ÌöåÍ∞Ä ÏàòÌñâÎêòÏóàÎäîÏßÄ ÌôïÏù∏
        XCTAssertTrue(mockCacheManager.getRequests.contains(cacheKey))
    }
    
    func testUpdateProfile_Success() async throws {
        // Given
        let updatedUser = TestDataFactory.updatedUser
        mockNetworkClient.postResponses["/users/1"] = updatedUser
        
        // When
        try await withTestScope {
            let service = ResilientUserService()
            try await service.updateProfile(name: "ÏóÖÎç∞Ïù¥Ìä∏Îêú ÏÇ¨Ïö©Ïûê", email: "updated@example.com")
        }
        
        // Then
        XCTAssertEqual(mockNetworkClient.postRequests.count, 1)
        
        let postRequest = mockNetworkClient.postRequests.first
        XCTAssertEqual(postRequest?.endpoint, "/users/1")
        
        // POST ÏöîÏ≤≠ Î∞îÎîî ÌôïÏù∏
        if let requestBody = postRequest?.body as? [String: String] {
            XCTAssertEqual(requestBody["name"], "ÏóÖÎç∞Ïù¥Ìä∏Îêú ÏÇ¨Ïö©Ïûê")
            XCTAssertEqual(requestBody["email"], "updated@example.com")
        }
        
        // ÏÑ±Í≥µ Î°úÍ∑∏ ÌôïÏù∏
        XCTAssertTrue(mockLogger.infoMessages.contains { $0.contains("ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ ÏÑ±Í≥µ") })
    }
    
    func testUpdateProfile_InvalidInput() async throws {
        // Given & When & Then
        await withTestScope {
            let service = ResilientUserService()
            
            // Îπà Ïù¥Î¶ÑÏúºÎ°ú ÌÖåÏä§Ìä∏
            do {
                try await service.updateProfile(name: "", email: "test@example.com")
                XCTFail("ÏóêÎü¨Í∞Ä Î∞úÏÉùÌï¥Ïïº Ìï©ÎãàÎã§")
            } catch {
                XCTAssertTrue(error is UserError)
                if case .invalidInput = error as? UserError {
                    // Ïò¨Î∞îÎ•∏ ÏóêÎü¨ ÌÉÄÏûÖ
                } else {
                    XCTFail("UserError.invalidInputÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§")
                }
            }
            
            // ÏûòÎ™ªÎêú Ïù¥Î©îÏùºÎ°ú ÌÖåÏä§Ìä∏
            do {
                try await service.updateProfile(name: "ÌÖåÏä§Ìä∏", email: "invalid-email")
                XCTFail("ÏóêÎü¨Í∞Ä Î∞úÏÉùÌï¥Ïïº Ìï©ÎãàÎã§")
            } catch {
                XCTAssertTrue(error is UserError)
            }
        }
        
        // ÎÑ§Ìä∏ÏõåÌÅ¨ ÏöîÏ≤≠Ïù¥ Ìò∏Ï∂úÎêòÏßÄ ÏïäÏïòÎäîÏßÄ ÌôïÏù∏
        XCTAssertEqual(mockNetworkClient.postRequests.count, 0)
    }
}
```

**6.4 Ï∫êÏãúÎêú ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÑúÎπÑÏä§ ÌÖåÏä§Ìä∏**
```swift
// Tests/TutorialTests/Services/CachedNetworkServiceTests.swift
import XCTest
@testable import Tutorial
import Weaver

final class CachedNetworkServiceTests: WeaverTestCase {
    
    func testGetCachedData_CacheMiss() async throws {
        // Given
        let expectedUser = TestDataFactory.sampleUser
        mockNetworkClient.getResponses["/users/1"] = expectedUser
        
        // When
        let result: User = try await withTestScope {
            let service = CachedNetworkService()
            return try await service.getCachedData("/users/1", type: User.self)
        }
        
        // Then
        XCTAssertEqual(result.id, expectedUser.id)
        
        // ÎÑ§Ìä∏ÏõåÌÅ¨ ÏöîÏ≤≠Ïù¥ Ìò∏Ï∂úÎêòÏóàÎäîÏßÄ ÌôïÏù∏
        XCTAssertEqual(mockNetworkClient.getRequests.count, 1)
        
        // Ï∫êÏãúÏóê Ï†ÄÏû•ÎêòÏóàÎäîÏßÄ ÌôïÏù∏
        XCTAssertEqual(mockCacheManager.setRequests.count, 1)
        XCTAssertEqual(mockCacheManager.setRequests.first?.key, "cached_/users/1")
    }
    
    func testGetCachedData_CacheHit() async throws {
        // Given
        let cachedUser = TestDataFactory.sampleUser
        let cacheKey = "cached_/users/1"
        await mockCacheManager.set(cacheKey, value: cachedUser)
        
        // When
        let result: User = try await withTestScope {
            let service = CachedNetworkService()
            return try await service.getCachedData("/users/1", type: User.self)
        }
        
        // Then
        XCTAssertEqual(result.id, cachedUser.id)
        
        // ÎÑ§Ìä∏ÏõåÌÅ¨ ÏöîÏ≤≠Ïù¥ Ìò∏Ï∂úÎêòÏßÄ ÏïäÏïòÎäîÏßÄ ÌôïÏù∏
        XCTAssertEqual(mockNetworkClient.getRequests.count, 0)
        
        // Ï∫êÏãú Ï°∞ÌöåÍ∞Ä ÏàòÌñâÎêòÏóàÎäîÏßÄ ÌôïÏù∏
        XCTAssertTrue(mockCacheManager.getRequests.contains(cacheKey))
    }
    
    func testGetCachedData_ForceRefresh() async throws {
        // Given
        let cachedUser = TestDataFactory.sampleUser
        let freshUser = TestDataFactory.updatedUser
        let cacheKey = "cached_/users/1"
        
        await mockCacheManager.set(cacheKey, value: cachedUser)
        mockNetworkClient.getResponses["/users/1"] = freshUser
        
        // When
        let result: User = try await withTestScope {
            let service = CachedNetworkService()
            return try await service.getCachedData("/users/1", type: User.self, forceRefresh: true)
        }
        
        // Then
        XCTAssertEqual(result.id, freshUser.id)
        XCTAssertEqual(result.name, freshUser.name)
        
        // Í∞ïÏ†ú ÏÉàÎ°úÍ≥†Ïπ®Ïù¥ÎØÄÎ°ú ÎÑ§Ìä∏ÏõåÌÅ¨ ÏöîÏ≤≠Ïù¥ Ìò∏Ï∂úÎêòÏñ¥Ïïº Ìï®
        XCTAssertEqual(mockNetworkClient.getRequests.count, 1)
        
        // ÏÉàÎ°úÏö¥ Îç∞Ïù¥ÌÑ∞Í∞Ä Ï∫êÏãúÏóê Ï†ÄÏû•ÎêòÏóàÎäîÏßÄ ÌôïÏù∏
        XCTAssertEqual(mockCacheManager.setRequests.count, 1)
    }
    
    func testPostWithCache_InvalidatesCacheKeys() async throws {
        // Given
        let request = ["name": "ÌÖåÏä§Ìä∏", "email": "test@example.com"]
        let response = TestDataFactory.updatedUser
        mockNetworkClient.postResponses["/users/1"] = response
        
        // When
        let result: User = try await withTestScope {
            let service = CachedNetworkService()
            return try await service.postWithCache(
                "/users/1",
                body: request,
                responseType: User.self,
                invalidateCacheKeys: ["cached_/users/1", "cached_/users/list"]
            )
        }
        
        // Then
        XCTAssertEqual(result.id, response.id)
        
        // POST ÏöîÏ≤≠Ïù¥ Ìò∏Ï∂úÎêòÏóàÎäîÏßÄ ÌôïÏù∏
        XCTAssertEqual(mockNetworkClient.postRequests.count, 1)
        
        // Ï∫êÏãú Î¨¥Ìö®Ìôî Î°úÍ∑∏Í∞Ä Í∏∞Î°ùÎêòÏóàÎäîÏßÄ ÌôïÏù∏
        XCTAssertTrue(mockLogger.infoMessages.contains { $0.contains("Ï∫êÏãú Î¨¥Ìö®Ìôî") })
    }
}
```

**6.5 ÏóêÎü¨ Ï≤òÎ¶¨ ÏÑúÎπÑÏä§ ÌÖåÏä§Ìä∏**
```swift
// Tests/TutorialTests/Services/ErrorHandlingServiceTests.swift
import XCTest
@testable import Tutorial
import Weaver

final class ErrorHandlingServiceTests: WeaverTestCase {
    
    func testHandleError_NetworkError() async throws {
        // Given
        let networkError = NetworkError.serverError(500)
        
        // When
        let result = await withTestScope {
            let service = DefaultErrorHandlingService()
            return await service.handleError(networkError)
        }
        
        // Then
        if case .network(let wrappedError) = result {
            XCTAssertTrue(wrappedError is NetworkError)
        } else {
            XCTFail("NetworkErrorÎ°ú ÎûòÌïëÎêòÏñ¥Ïïº Ìï©ÎãàÎã§")
        }
        
        // ÏóêÎü¨ Î°úÍ∑∏Í∞Ä Í∏∞Î°ùÎêòÏóàÎäîÏßÄ ÌôïÏù∏
        XCTAssertTrue(mockLogger.errorMessages.contains { $0.contains("ÏóêÎü¨ Ï≤òÎ¶¨") })
    }
    
    func testShouldRetry_RetryableErrors() async throws {
        // Given
        let service = DefaultErrorHandlingService()
        
        // When & Then
        await withTestScope {
            // ÏÑúÎ≤Ñ ÏóêÎü¨Îäî Ïû¨ÏãúÎèÑ Í∞ÄÎä•
            let serverError = AppError.network(.serverError(500))
            XCTAssertTrue(service.shouldRetry(serverError))
            
            // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏóêÎü¨Îäî Ïû¨ÏãúÎèÑ Î∂àÍ∞ÄÎä•
            let clientError = AppError.network(.clientError(400))
            XCTAssertFalse(service.shouldRetry(clientError))
            
            // ÏÇ¨Ïö©Ïûê ÏóêÎü¨Îäî Ïû¨ÏãúÎèÑ Î∂àÍ∞ÄÎä•
            let userError = AppError.user(.invalidInput)
            XCTAssertFalse(service.shouldRetry(userError))
        }
    }
    
    func testGetRetryDelay_ExponentialBackoff() async throws {
        // Given
        let service = DefaultErrorHandlingService()
        let error = AppError.network(.serverError(500))
        
        // When & Then
        await withTestScope {
            // ÏßÄÏàò Î∞±Ïò§ÌîÑ ÌôïÏù∏
            XCTAssertEqual(service.getRetryDelay(error, attempt: 1), 2.0)  // 2^1
            XCTAssertEqual(service.getRetryDelay(error, attempt: 2), 4.0)  // 2^2
            XCTAssertEqual(service.getRetryDelay(error, attempt: 3), 8.0)  // 2^3
            XCTAssertEqual(service.getRetryDelay(error, attempt: 4), 16.0) // 2^4
            
            // ÏµúÎåÄ 30Ï¥à Ï†úÌïú ÌôïÏù∏
            XCTAssertEqual(service.getRetryDelay(error, attempt: 10), 30.0)
        }
    }
}
```

**6.6 ÌÜµÌï© ÌÖåÏä§Ìä∏**
```swift
// Tests/TutorialTests/Integration/UserProfileIntegrationTests.swift
import XCTest
@testable import Tutorial
import Weaver

final class UserProfileIntegrationTests: WeaverTestCase {
    
    func testUserProfileFlow_SuccessPath() async throws {
        // Given
        let initialUser = TestDataFactory.sampleUser
        let updatedUser = TestDataFactory.updatedUser
        
        mockNetworkClient.getResponses["/users/1"] = initialUser
        mockNetworkClient.postResponses["/users/1"] = updatedUser
        
        // When & Then - ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Î°úÎî©
        let loadedUser = try await withTestScope {
            let service = ResilientUserService()
            return try await service.getCurrentUser()
        }
        
        XCTAssertEqual(loadedUser?.id, initialUser.id)
        XCTAssertEqual(loadedUser?.name, initialUser.name)
        
        // When & Then - ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏
        try await withTestScope {
            let service = ResilientUserService()
            try await service.updateProfile(name: updatedUser.name, email: updatedUser.email)
        }
        
        // Ï†ÑÏ≤¥ ÌîåÎ°úÏö∞ Í≤ÄÏ¶ù
        XCTAssertEqual(mockNetworkClient.getRequests.count, 1)
        XCTAssertEqual(mockNetworkClient.postRequests.count, 1)
        
        // Ï∫êÏãú ÎèôÏûë Í≤ÄÏ¶ù
        XCTAssertEqual(mockCacheManager.setRequests.count, 1) // GET ÏùëÎãµ Ï∫êÏãú
        
        // Î°úÍ∑∏ Í≤ÄÏ¶ù
        XCTAssertTrue(mockLogger.infoMessages.contains { $0.contains("ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏöîÏ≤≠ ÏÑ±Í≥µ") })
        XCTAssertTrue(mockLogger.infoMessages.contains { $0.contains("ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ ÏÑ±Í≥µ") })
    }
    
    func testUserProfileFlow_NetworkFailureRecovery() async throws {
        // Given
        let user = TestDataFactory.sampleUser
        
        // Ï≤òÏùå 2Î≤àÏùÄ Ïã§Ìå®, 3Î≤àÏß∏Îäî ÏÑ±Í≥µ
        var callCount = 0
        mockNetworkClient.shouldFail = true
        mockNetworkClient.failureError = NetworkError.serverError(500)
        
        // 3Î≤àÏß∏ Ìò∏Ï∂úÏóêÏÑú ÏÑ±Í≥µÌïòÎèÑÎ°ù ÏÑ§Ï†ï
        let originalGet = mockNetworkClient.get
        mockNetworkClient.get = { endpoint in
            callCount += 1
            if callCount >= 3 {
                self.mockNetworkClient.shouldFail = false
                self.mockNetworkClient.getResponses[endpoint] = user
            }
            return try await originalGet(endpoint)
        }
        
        // When
        let result = try await withTestScope {
            let service = ResilientUserService()
            return try await service.getCurrentUser()
        }
        
        // Then
        XCTAssertEqual(result?.id, user.id)
        XCTAssertEqual(mockNetworkClient.getRequests.count, 3) // 3Î≤à ÏãúÎèÑ
        
        // Ïû¨ÏãúÎèÑ Î°úÍ∑∏ ÌôïÏù∏
        XCTAssertTrue(mockLogger.infoMessages.contains { $0.contains("Ïû¨ÏãúÎèÑ ÎåÄÍ∏∞") })
        XCTAssertTrue(mockLogger.infoMessages.contains { $0.contains("ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏöîÏ≤≠ ÏÑ±Í≥µ") })
    }
}
```

**6.7 ÏÑ±Îä• ÌÖåÏä§Ìä∏**
```swift
// Tests/TutorialTests/Performance/PerformanceTests.swift
import XCTest
@testable import Tutorial
import Weaver

final class PerformanceTests: WeaverTestCase {
    
    func testUserServicePerformance() async throws {
        // Given
        let user = TestDataFactory.sampleUser
        mockNetworkClient.getResponses["/users/1"] = user
        
        // When & Then
        measure {
            let expectation = XCTestExpectation(description: "User service performance")
            
            Task {
                try await self.withTestScope {
                    let service = ResilientUserService()
                    _ = try await service.getCurrentUser()
                }
                expectation.fulfill()
            }
            
            wait(for: [expectation], timeout: 1.0)
        }
    }
    
    func testCachePerformance() async throws {
        // Given
        let users = TestDataFactory.createUsers(count: 100)
        
        // Ï∫êÏãúÏóê 100Í∞ú ÏÇ¨Ïö©Ïûê Ï†ÄÏû•
        for (index, user) in users.enumerated() {
            await mockCacheManager.set("user_\(index)", value: user)
        }
        
        // When & Then - Ï∫êÏãú Ï°∞Ìöå ÏÑ±Îä• Ï∏°Ï†ï
        measure {
            let expectation = XCTestExpectation(description: "Cache performance")
            
            Task {
                for index in 0..<100 {
                    _ = await self.mockCacheManager.get("user_\(index)", type: User.self)
                }
                expectation.fulfill()
            }
            
            wait(for: [expectation], timeout: 1.0)
        }
    }
}
```

#### üí° ÌïµÏã¨ Ìè¨Ïù∏Ìä∏
- Mock Í∞ùÏ≤¥Î•º ÏÇ¨Ïö©ÌïòÏó¨ Ïô∏Î∂Ä ÏùòÏ°¥ÏÑ±ÏùÑ Ï†úÍ±∞Ìï©ÎãàÎã§
- `WeaverTestCase` Î≤†Ïù¥Ïä§ ÌÅ¥ÎûòÏä§Î°ú ÌÖåÏä§Ìä∏ ÏÑ§Ï†ïÏùÑ ÌëúÏ§ÄÌôîÌï©ÎãàÎã§
- Îã®ÏúÑ ÌÖåÏä§Ìä∏, ÌÜµÌï© ÌÖåÏä§Ìä∏, ÏÑ±Îä• ÌÖåÏä§Ìä∏Î•º Î™®Îëê ÏûëÏÑ±Ìï©ÎãàÎã§
- ÌÖåÏä§Ìä∏ÏóêÏÑúÎèÑ DI Ïª®ÌÖåÏù¥ÎÑàÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÏùºÍ¥ÄÏÑ±ÏùÑ Ïú†ÏßÄÌï©ÎãàÎã§

**üéâ Ï§ëÍ∏â Î†àÎ≤® ÏôÑÎ£å!** Ïù¥Ï†ú Ïã§Ï†ú ÌîÑÎ°úÎçïÏÖò Ïï±ÏóêÏÑú ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎäî ÏàòÏ§ÄÏùò Weaver DI ÏãúÏä§ÌÖúÏùÑ Íµ¨Ï∂ïÌñàÏäµÎãàÎã§.

---

## üî¥ Í≥†Í∏â Î†àÎ≤®

Í≥†Í∏â Î†àÎ≤®ÏóêÏÑúÎäî Ïã§Ï†ú ÌîÑÎ°úÎçïÏÖò Ïï±ÏóêÏÑú ÌïÑÏöîÌïú Î≥µÏû°Ìïú Ìå®ÌÑ¥Îì§ÏùÑ Îã§Î£πÎãàÎã§. Ïù∏Ï¶ù ÏãúÏä§ÌÖú, ÏÑ±Îä• ÏµúÏ†ÅÌôî, A/B ÌÖåÏä§Ìä∏ Îì± Í≥†Í∏â Ï£ºÏ†úÎì§ÏùÑ ÌïôÏäµÌï©ÎãàÎã§.

### 7Îã®Í≥Ñ: Ïù∏Ï¶ù ÏãúÏä§ÌÖú Íµ¨ÌòÑ

#### üéØ ÌïôÏäµ Î™©Ìëú
- JWT ÌÜ†ÌÅ∞ Í∏∞Î∞ò Ïù∏Ï¶ù ÏãúÏä§ÌÖú
- ÏûêÎèô ÌÜ†ÌÅ∞ Í∞±Ïã† Î©îÏª§ÎãàÏ¶ò
- ÌÇ§Ï≤¥Ïù∏ÏùÑ ÌôúÏö©Ìïú Î≥¥Ïïà Ï†ÄÏû•ÏÜå

#### üìù Ïã§Ïäµ: ÏôÑÏ†ÑÌïú Ïù∏Ï¶ù ÏãúÏä§ÌÖú

**7.1 Ïù∏Ï¶ù ÌÜ†ÌÅ∞ Î™®Îç∏**
```swift
// Models/AuthToken.swift
import Foundation

struct AuthToken: Codable, Sendable {
    let accessToken: String
    let refreshToken: String
    let tokenType: String
    let expiresIn: Int
    let scope: String?
    
    private let issuedAt: Date
    
    init(accessToken: String, refreshToken: String, tokenType: String = "Bearer", expiresIn: Int, scope: String? = nil) {
        self.accessToken = accessToken
        self.refreshToken = refreshToken
        self.tokenType = tokenType
        self.expiresIn = expiresIn
        self.scope = scope
        self.issuedAt = Date()
    }
    
    var expiresAt: Date {
        issuedAt.addingTimeInterval(TimeInterval(expiresIn))
    }
    
    var isExpired: Bool {
        Date() >= expiresAt
    }
    
    var willExpireSoon: Bool {
        // ÎßåÎ£å 5Î∂Ñ Ï†ÑÏùÑ "Í≥ß ÎßåÎ£å"Î°ú Í∞ÑÏ£º
        Date().addingTimeInterval(300) >= expiresAt
    }
    
    var authorizationHeader: String {
        "\(tokenType) \(accessToken)"
    }
}

// Î°úÍ∑∏Ïù∏ ÏöîÏ≤≠/ÏùëÎãµ Î™®Îç∏
struct LoginRequest: Codable {
    let email: String
    let password: String
    let deviceId: String
    let deviceName: String
}

struct LoginResponse: Codable {
    let accessToken: String
    let refreshToken: String
    let tokenType: String
    let expiresIn: Int
    let user: User
}

struct RefreshTokenRequest: Codable {
    let refreshToken: String
}

struct RefreshTokenResponse: Codable {
    let accessToken: String
    let refreshToken: String
    let tokenType: String
    let expiresIn: Int
}
```
